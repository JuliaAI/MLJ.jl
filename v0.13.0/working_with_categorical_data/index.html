<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Working with Categorical Data · MLJ</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="MLJ logo"/></a><div class="docs-package-name"><span class="docs-autofit">MLJ</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../getting_started/">Getting Started</a></li><li><a class="tocitem" href="../common_mlj_workflows/">Common MLJ Workflows</a></li><li class="is-active"><a class="tocitem" href>Working with Categorical Data</a><ul class="internal"><li><a class="tocitem" href="#Scientific-types-for-discrete-data-1"><span>Scientific types for discrete data</span></a></li><li><a class="tocitem" href="#Detecting-and-coercing-improperly-represented-categorical-data-1"><span>Detecting and coercing improperly represented categorical data</span></a></li><li><a class="tocitem" href="#Tracking-all-levels-1"><span>Tracking all levels</span></a></li><li><a class="tocitem" href="#Extracting-an-integer-representation-of-Finite-data-1"><span>Extracting an integer representation of Finite data</span></a></li><li><a class="tocitem" href="#Under-the-hood:-CategoricalValue-and-CategoricalArray-1"><span>Under the hood: CategoricalValue and CategoricalArray</span></a></li><li><a class="tocitem" href="#Probabilistic-predictions-of-categorical-data-1"><span>Probabilistic predictions of categorical data</span></a></li></ul></li><li><a class="tocitem" href="../model_search/">Model Search</a></li><li><a class="tocitem" href="../machines/">Machines</a></li><li><a class="tocitem" href="../evaluating_model_performance/">Evaluating Model Performance</a></li><li><a class="tocitem" href="../performance_measures/">Performance Measures</a></li><li><a class="tocitem" href="../tuning_models/">Tuning Models</a></li><li><a class="tocitem" href="../learning_curves/">Learning Curves</a></li><li><a class="tocitem" href="../transformers/">Transformers and other unsupervised models</a></li><li><a class="tocitem" href="../composing_models/">Composing Models</a></li><li><a class="tocitem" href="../homogeneous_ensembles/">Homogeneous Ensembles</a></li><li><a class="tocitem" href="../generating_synthetic_data/">Generating Synthetic Data</a></li><li><a class="tocitem" href="../openml_integration/">OpenML Integration</a></li><li><a class="tocitem" href="../simple_user_defined_models/">Simple User Defined Models</a></li><li><a class="tocitem" href="../quick_start_guide_to_adding_models/">Quick-Start Guide to Adding Models</a></li><li><a class="tocitem" href="../adding_models_for_general_use/">Adding Models for General Use</a></li><li><a class="tocitem" href="../benchmarking/">Benchmarking</a></li><li><a class="tocitem" href="../internals/">Internals</a></li><li><a class="tocitem" href="../glossary/">Glossary</a></li><li><a class="tocitem" href="../mlj_cheatsheet/">MLJ Cheatsheet</a></li><li><a class="tocitem" href="../frequently_asked_questions/">FAQ</a></li><li><a class="tocitem" href="../julia_blogpost/">Julia BlogPost</a></li><li><a class="tocitem" href="../acceleration_and_parallelism/">Acceleration and Parallelism</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Working with Categorical Data</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Working with Categorical Data</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/alan-turing-institute/MLJ.jl/blob/master/docs/src/working_with_categorical_data.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Working-with-Categorical-Data-1"><a class="docs-heading-anchor" href="#Working-with-Categorical-Data-1">Working with Categorical Data</a><a class="docs-heading-anchor-permalink" href="#Working-with-Categorical-Data-1" title="Permalink"></a></h1><h2 id="Scientific-types-for-discrete-data-1"><a class="docs-heading-anchor" href="#Scientific-types-for-discrete-data-1">Scientific types for discrete data</a><a class="docs-heading-anchor-permalink" href="#Scientific-types-for-discrete-data-1" title="Permalink"></a></h2><p>Recall that models articulate their data requirements using scientific types (see <a href="../getting_started/#Getting-Started-1">Getting Started</a> or the <a href="https://alan-turing-institute.github.io/MLJScientificTypes.jl/dev/">MLJScientificTypes.jl documentation</a>). There are three scientific types discrete data can have: <code>Count</code>, <code>OrderedFactor</code> and <code>Multiclass</code>.</p><h3 id="Count-data-1"><a class="docs-heading-anchor" href="#Count-data-1">Count data</a><a class="docs-heading-anchor-permalink" href="#Count-data-1" title="Permalink"></a></h3><p>In MLJ you cannot use integers to represent (finite) categorical data. Integers are reserved for discrete data you want interpreted as <code>Count &lt;: Infinite</code>:</p><pre><code class="language-julia">scitype([1, 4, 5, 6])</code></pre><pre><code class="language-none">AbstractArray{Count,1}</code></pre><p>The <code>Count</code> scientific type includes things like the number of phone calls, or city populations, and other &quot;frequency&quot; data of a generally unbounded nature.</p><p>That said, you may have data that is theoretically <code>Count</code>, but which you coerce to <code>OrderedFactor</code> to enable the use of more models, trusting to your knowledge of how those models work to inform an appropriate interpretation.</p><h3 id="OrderedFactor-and-Multiclass-data-1"><a class="docs-heading-anchor" href="#OrderedFactor-and-Multiclass-data-1">OrderedFactor and Multiclass data</a><a class="docs-heading-anchor-permalink" href="#OrderedFactor-and-Multiclass-data-1" title="Permalink"></a></h3><p>Other integer data, such as the number of an animal&#39;s legs, or number of rooms of homes, are generally coerced to <code>OrderedFactor &lt;: Finite</code>. The other categorical scientific type is <code>Multiclass &lt;: Finite</code>, which is for <em>unordered</em> categorical data. Coercing data to one of these two forms is discussed under <a href="#Detecting-and-coercing-improperly-represented-categorical-data-1"> Detecting and coercing improperly represented categorical data</a> below.</p><h3 id="Binary-data-1"><a class="docs-heading-anchor" href="#Binary-data-1">Binary data</a><a class="docs-heading-anchor-permalink" href="#Binary-data-1" title="Permalink"></a></h3><p>There is no separate scientific type for binary data. Binary data is either <code>OrderedFactor{2}</code> if ordered, and <code>Multiclass{2}</code> otherwise. Data with type <code>OrderedFactor{2}</code> is considered to have an intrinsic &quot;positive&quot; class, e.g., the outcome of a medical test, and the &quot;pass/fail&quot; outcome of an exam. MLJ measures, such as <code>true_positive</code> assume the <em>second</em> class in the ordering is the &quot;positive&quot; class. Inspecting and changing order is discussed in the next section.</p><p>If data has type <code>Bool</code> it is considered <code>Count</code> data (as <code>Bool &lt;: Integer</code>) and generally users will want to coerce such data to <code>Multiclass</code> or <code>OrderedFactor</code>.</p><h2 id="Detecting-and-coercing-improperly-represented-categorical-data-1"><a class="docs-heading-anchor" href="#Detecting-and-coercing-improperly-represented-categorical-data-1">Detecting and coercing improperly represented categorical data</a><a class="docs-heading-anchor-permalink" href="#Detecting-and-coercing-improperly-represented-categorical-data-1" title="Permalink"></a></h2><p>One inspects the scientific type of data using <code>scitype</code> as shown above. To inspect all column scientific types in a table simultaneously, use <code>schema</code>. (The <code>scitype(X)</code> of a table <code>X</code> contains a condensed form of this information used in type dispatch; see <a href="https://github.com/alan-turing-institute/ScientificTypes.jl#more-on-the-table-type">here</a>.)</p><pre><code class="language-julia">using DataFrames
X = DataFrame(
                 name       = [&quot;Siri&quot;, &quot;Robo&quot;, &quot;Alexa&quot;, &quot;Cortana&quot;],
                 gender     = [&quot;male&quot;, &quot;male&quot;, &quot;Female&quot;, &quot;female&quot;],
                 likes_soup = [true, false, false, true],
                 height     = [152, missing, 148, 163],
                 rating     = [2, 5, 2, 1],
                 outcome    = [&quot;rejected&quot;, &quot;accepted&quot;, &quot;accepted&quot;, &quot;rejected&quot;])
schema(X)</code></pre><pre><code class="language-none">┌────────────┬───────────────────────┬───────────────────────┐
│ _.names    │ _.types               │ _.scitypes            │
├────────────┼───────────────────────┼───────────────────────┤
│ name       │ String                │ Textual               │
│ gender     │ String                │ Textual               │
│ likes_soup │ Bool                  │ Count                 │
│ height     │ Union{Missing, Int64} │ Union{Missing, Count} │
│ rating     │ Int64                 │ Count                 │
│ outcome    │ String                │ Textual               │
└────────────┴───────────────────────┴───────────────────────┘
_.nrows = 4
</code></pre><p>Coercing a single column:</p><pre><code class="language-julia">X.outcome = coerce(X.outcome, OrderedFactor)</code></pre><pre><code class="language-none">4-element CategoricalArray{String,1,UInt32}:
 &quot;rejected&quot;
 &quot;accepted&quot;
 &quot;accepted&quot;
 &quot;rejected&quot;</code></pre><p>The <em>machine</em> type of the result is a <code>CategoricalArray</code>. For more on this type see <a href="#Under-the-hood:-CategoricalValue-and-CategoricalArray-1">Under the hood: CategoricalValue and CategoricalArray</a> below.</p><p>Inspecting the order of the levels:</p><pre><code class="language-julia">levels(X.outcome)</code></pre><pre><code class="language-none">2-element Array{String,1}:
 &quot;accepted&quot;
 &quot;rejected&quot;</code></pre><p>Since we wish to regard &quot;accepted&quot; as the positive class, it should appear second, which we correct with the <code>levels!</code> function:</p><pre><code class="language-julia">levels!(X.outcome, [&quot;rejected&quot;, &quot;accepted&quot;])
levels(X.outcome)</code></pre><pre><code class="language-none">2-element Array{String,1}:
 &quot;rejected&quot;
 &quot;accepted&quot;</code></pre><div class="admonition is-warning"><header class="admonition-header">Changing levels of categorical data</header><div class="admonition-body"><p>The order of levels should generally be changed early in your data science work-flow and then not again. Similar remarks apply to <em>adding</em> levels (which is possible; see the <a href="https://juliadata.github.io/CategoricalArrays.jl/stable/">CategorialArrays.jl documentation</a>). MLJ supervised and unsupervised models assume levels and their order do not change.</p></div></div><p>Coercing all remaining types simultaneously:</p><pre><code class="language-julia">Xnew = coerce(X, :gender    =&gt; Multiclass,
                 :like_soup =&gt; OrderedFactor,
                 :height    =&gt; Continuous,
                 :rating    =&gt; OrderedFactor)
schema(Xnew)</code></pre><pre><code class="language-none">┌────────────┬─────────────────────────────────┬────────────────────────────┐
│ _.names    │ _.types                         │ _.scitypes                 │
├────────────┼─────────────────────────────────┼────────────────────────────┤
│ name       │ String                          │ Textual                    │
│ gender     │ CategoricalValue{String,UInt32} │ Multiclass{3}              │
│ likes_soup │ Bool                            │ Count                      │
│ height     │ Union{Missing, Float64}         │ Union{Missing, Continuous} │
│ rating     │ CategoricalValue{Int64,UInt32}  │ OrderedFactor{3}           │
│ outcome    │ CategoricalValue{String,UInt32} │ OrderedFactor{2}           │
└────────────┴─────────────────────────────────┴────────────────────────────┘
_.nrows = 4
</code></pre><p>For <code>DataFrame</code>s there is also in-place coercion, using <code>coerce!</code>.</p><h2 id="Tracking-all-levels-1"><a class="docs-heading-anchor" href="#Tracking-all-levels-1">Tracking all levels</a><a class="docs-heading-anchor-permalink" href="#Tracking-all-levels-1" title="Permalink"></a></h2><p>The key property of vectors of scientific type <code>OrderedFactor</code> and  <code>Multiclass</code> is that the pool of all levels is not lost when separating out one or more elements:</p><pre><code class="language-julia">v = Xnew.rating</code></pre><pre><code class="language-none">4-element CategoricalArray{Int64,1,UInt32}:
 2
 5
 2
 1</code></pre><pre><code class="language-julia">levels(v)</code></pre><pre><code class="language-none">3-element Array{Int64,1}:
 1
 2
 5</code></pre><pre><code class="language-julia">levels(v[1:2])</code></pre><pre><code class="language-none">3-element Array{Int64,1}:
 1
 2
 5</code></pre><pre><code class="language-julia">levels(v[2])</code></pre><pre><code class="language-none">3-element Array{Int64,1}:
 1
 2
 5</code></pre><p>By tracking all classes in this way, MLJ avoids common pain points around categorical data, such as evaluating models on an evaluation set, only to crash your code because classes appear there which were not seen during training.</p><h2 id="Extracting-an-integer-representation-of-Finite-data-1"><a class="docs-heading-anchor" href="#Extracting-an-integer-representation-of-Finite-data-1">Extracting an integer representation of Finite data</a><a class="docs-heading-anchor-permalink" href="#Extracting-an-integer-representation-of-Finite-data-1" title="Permalink"></a></h2><p>Occasionally, you may really want an integer representation of data that currently has scitype <code>Finite</code>. For example, you are developer wrapping an algorithm from an external package for use in MLJ, and that algorithm uses integer representations. Use the <code>int</code> method for this purpose, and use <code>decoder</code> to construct decoders for reversing the transformation:</p><pre><code class="language-julia">v = coerce([:one, :two, :three, :one], OrderedFactor);
levels!(v, [:one, :two, :three]);
v_int = int(v)</code></pre><pre><code class="language-none">4-element Array{UInt32,1}:
 0x00000001
 0x00000002
 0x00000003
 0x00000001</code></pre><pre><code class="language-julia">d = decoder(v); # or decoder(v[1])
d.(v_int)</code></pre><pre><code class="language-none">4-element CategoricalArray{Symbol,1,UInt32}:
 :one  
 :two  
 :three
 :one  </code></pre><h2 id="Under-the-hood:-CategoricalValue-and-CategoricalArray-1"><a class="docs-heading-anchor" href="#Under-the-hood:-CategoricalValue-and-CategoricalArray-1">Under the hood: CategoricalValue and CategoricalArray</a><a class="docs-heading-anchor-permalink" href="#Under-the-hood:-CategoricalValue-and-CategoricalArray-1" title="Permalink"></a></h2><p>In MLJ the objects with <code>OrderedFactor</code> or <code>Multiclass</code> scientific type have machine type <code>CategoricalValue</code>, from the <a href="https://juliadata.github.io/CategoricalArrays.jl/stable/">CategoricalArrays.jl</a> package. In some sense <code>CategoricalValue</code>s are an implementation detail users can ignore for the most part, as shown above. However, you may want some basic understanding of these types, and those implementing MLJ&#39;s model interface for new algorithms will have to understand them. For the complete API, see the CategoricalArrays.jl <a href="https://juliadata.github.io/CategoricalArrays.jl/stable/">documentation</a>. Here are the basics:</p><p>To construct an <code>OrderedFactor</code> or <code>Multiclass</code> vector directly from raw labels, one uses <code>categorical</code>:</p><pre><code class="language-julia">v = categorical([:A, :B, :A, :A, :C])
typeof(v)</code></pre><pre><code class="language-none">CategoricalArray{Symbol,1,UInt32,Symbol,CategoricalValue{Symbol,UInt32},Union{}}</code></pre><p>(Equivalent to the idiomatically MLJ <code>v = coerce([:A, :B, :A, :A, :C]), Multiclass)</code>.)</p><pre><code class="language-julia">scitype(v)</code></pre><pre><code class="language-none">AbstractArray{Multiclass{3},1}</code></pre><pre><code class="language-julia">v = categorical([:A, :B, :A, :A, :C], ordered=true, compress=true)</code></pre><pre><code class="language-none">5-element CategoricalArray{Symbol,1,UInt8}:
 :A
 :B
 :A
 :A
 :C</code></pre><pre><code class="language-julia">scitype(v)</code></pre><pre><code class="language-none">AbstractArray{OrderedFactor{3},1}</code></pre><p>When you index a <code>CategoricalVector</code> you don&#39;t get a raw label, but instead an instance of <code>CategoricalValue</code>. As explained above, this value knows the complete pool of levels from vector from which it came. Use <code>get(val)</code> to extract the raw label from a value <code>val</code>.</p><p>Despite the distinction that exists between a value (element) and a label, the two are the same, from the point of <code>==</code> and <code>in</code>:</p><pre><code class="language-">v[1] == :A # true
:A in v    # true</code></pre><h2 id="Probabilistic-predictions-of-categorical-data-1"><a class="docs-heading-anchor" href="#Probabilistic-predictions-of-categorical-data-1">Probabilistic predictions of categorical data</a><a class="docs-heading-anchor-permalink" href="#Probabilistic-predictions-of-categorical-data-1" title="Permalink"></a></h2><p>Recall from <a href="../getting_started/#Getting-Started-1">Getting Started</a> that probabilistic classfiers ordinarily predict <code>UnivariateFinite</code> distributions, not raw probabilities (which are instead accessed using the <code>pdf</code> method.) Here&#39;s how to construct such a distribution yourself:</p><pre><code class="language-julia">v = coerce([:yes, :no, :yes, :yes, :maybe], Multiclass)
d = UnivariateFinite([v[1], v[2]], [0.9, 0.1])</code></pre><pre><code class="language-none">UnivariateFinite{Multiclass{3}}(no=&gt;0.1, yes=&gt;0.9)</code></pre><p>Or, equivalently,</p><pre><code class="language-julia">d = UnivariateFinite([:no, :yes], [0.9, 0.1], pool=v)</code></pre><pre><code class="language-none">UnivariateFinite{Multiclass{3}}(no=&gt;0.9, yes=&gt;0.1)</code></pre><p>This distribution tracks <em>all</em> levels, not just the ones to which you have assigned probabilities:</p><pre><code class="language-julia">pdf(d, :maybe)</code></pre><pre><code class="language-none">0.0</code></pre><p>However, <code>pdf(d, :dunno)</code> will throw an error.</p><p>You can declare <code>pool=missing</code>, but then <code>:maybe</code> will not be tracked:</p><pre><code class="language-julia">d = UnivariateFinite([:no, :yes], [0.9, 0.1], pool=missing)
levels(d)</code></pre><pre><code class="language-none">2-element Array{Symbol,1}:
 :no 
 :yes</code></pre><p>To construct a whole <em>vector</em> of <code>UnivariateFinite</code> distributions, simply give the constructor a matrix of probabilities:</p><pre><code class="language-julia">yes_probs = rand(5)
probs = hcat(1 .- yes_probs, yes_probs)
d_vec = UnivariateFinite([:no, :yes], probs, pool=v)</code></pre><pre><code class="language-none">5-element MLJBase.UnivariateFiniteArray{Multiclass{3},Symbol,UInt32,Float64,1}:
 UnivariateFinite{Multiclass{3}}(no=&gt;0.254, yes=&gt;0.746) 
 UnivariateFinite{Multiclass{3}}(no=&gt;0.729, yes=&gt;0.271) 
 UnivariateFinite{Multiclass{3}}(no=&gt;0.918, yes=&gt;0.0823)
 UnivariateFinite{Multiclass{3}}(no=&gt;0.308, yes=&gt;0.692) 
 UnivariateFinite{Multiclass{3}}(no=&gt;0.619, yes=&gt;0.381) </code></pre><p>Or, equivalently:</p><pre><code class="language-">d_vec = UnivariateFinite([:no, :yes], yes_probs, augment=true, pool=v)</code></pre><p>For more options, see <a href="../adding_models_for_general_use/#MLJBase.UnivariateFinite"><code>UnivariateFinite</code></a>. </p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../common_mlj_workflows/">« Common MLJ Workflows</a><a class="docs-footer-nextpage" href="../model_search/">Model Search »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 1 September 2020 04:33">Tuesday 1 September 2020</span>. Using Julia version 1.2.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
