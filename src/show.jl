## REGISTERING LABELS OF OBJECTS DURING ASSIGNMENT

const handle_given_id = Dict{UInt64,Symbol}()

"""
    @constant x = value

Equivalent to `const x = value` but registers the binding thus:

    MLJ.handle_given_id[objectid(value)] = :x

Registered objects get displayed using the variable name to which it was bound in calls to `show(x)`, etc. 

WARNING: As with any `const` declaration, binding `x` to new value of
the same type is not prevented and the registration will not be updated.

"""
macro constant(ex)
    ex.head == :(=) || throw(error("Expression must be an assignment."))
    handle = ex.args[1]
    value = ex.args[2]
    quote
        const $(esc(handle)) = $(esc(value))
        id = objectid($(esc(handle)))
        MLJ.handle_given_id[id] = @colon $handle
        $(esc(handle))
    end
end

"""to display abbreviated versions of integers"""
function abbreviated(n)
    as_string = string(n)
    return as_string[1]*"…"*as_string[end-1:end]
end

"""return abbreviated object id (as string)  or it's registered handle (as string) if this exists"""
function handle(X)
    id = objectid(X)
    if id in keys(handle_given_id)
        return string(handle_given_id[id])
    else
        return abbreviated(id)
    end
end


## EXPOSED SHOW METHODS

# short version of showing a `MLJType` object:
function Base.show(stream::IO, object::MLJType)
    id = objectid(object) 
    description = string(typeof(object).name.name)
    parameters = typeof(object).parameters
    if length(parameters) == 1
        p_string = string(parameters[1])
        if length(p_string) > 25
            p_string = p_string[1:24]*"…"
        end
        description *= "{"*p_string*"}"
    end
    #   description = string(typeof(object))
    str = "$description @ $(handle(object))"
    if !isempty(fieldnames(typeof(object)))
        printstyled(IOContext(stream, :color=> true), str, bold=true)#color=:blue
    else
        print(stream, str)
    end
end

# longer version of showing a `MLJType` object (used at REPL):
function Base.show(stream::IO, ::MIME"text/plain", object::MLJType)
    _recursive_show(stream, object, 1, DEFAULT_SHOW_DEPTH)
end

# version showing a `MLJType` object to arbitrary depth:
function Base.show(stream::IO, object::MLJType, depth::Int)
    _recursive_show(stream, object, 1, depth)
end

# for convenience:
Base.show(object::MLJType, depth::Int) = show(stdout, object, depth)

""" 
    @more

Entered at the REPL, equivalent to `show(ans, 100)`. Use to get a
recursive description of all fields of the last REPL value.

"""
macro more()
    esc(quote
        show(Main.ans, 100)
    end)
end    


## METHODS TO SUPRESS THE DISPLAY OF LARGE NON-BASETYPE OBJECTS

istoobig(::Any) = true
istoobig(::DataType) = false
istoobig(::Union) = false
istoobig(::Number) = false
istoobig(::Char) = false
istoobig(::Function) = false
istoobig(s::Symbol) = false
istoobig(str::AbstractString) = length(str) > 50

## THE `_show` METHOD

# Note: The `_show` method controls how field values are displayed in
# the table generated by `_recursive_show`. See top of file.

# _show fallback:
function _show(stream::IO, object)
    if !istoobig(object)
        show(stream, MIME("text/plain"), object)
        println(stream)
    else
        println(stream, "(omitted ", typeof(object), ")")
    end
end

_show(stream::IO, object::MLJType) = println(stream, object)

# _show for other types:

function _show(stream::IO, df::AbstractDataFrame)
    println(stream, "(omitted $(typeof(df)) of size $(size(df)))")
end

istoobig(t::Tuple{Vararg{T}}) where T<:Union{Number,Symbol,Char,MLJType} =
    length(t) > 5 
function _show(stream::IO, t::Tuple)
    if !istoobig(t)
        show(stream, MIME("text/plain"), t)
        println(stream)
    else
        println(stream, "(omitted $(typeof(t)) of length $(length(t)))")
    end
end

istoobig(A::AbstractArray{T}) where T<:Union{Number,Symbol,Char,MLJType} =
    maximum(size(A)) > 5 
function _show(stream::IO, A::AbstractArray)
    if !istoobig(A)
        show(stream, MIME("text/plain"), A)
        println(stream)
    else
        println(stream, "(omitted $(typeof(A)) of size $(size(A)))")
    end
end

istoobig(d::Dict{T,Any}) where T <: Union{Number,Symbol,Char,MLJType} =
    length(keys(d)) > 5
function _show(stream::IO, d::Dict{T, Any}) where T <: Union{Number,Symbol}
    if isempty(d)
        println(stream, "empty $(typeof(d))")
    elseif !istoobig(d)
        println(stream, "omitted $(typeof(d)) with keys: ")
        show(stream, MIME("text/plain"), collect(keys(d)))
        println(stream)
    else
        println(stream, "(omitted $(typeof(d)))")
    end
end

function _show(stream::IO, v::Array{T, 1}) where T
    if !istoobig(v)
        show(stream, MIME("text/plain"), v)
        println(stream)
    else
        println(stream, "(omitted Vector{$T} of length $(length(v)))")
    end
end

_show(stream::IO, T::DataType) = println(stream, T) 

_show(stream::IO, ::Nothing) = println(stream, "nothing")


## THE RECURSIVE SHOW METHOD

"""
    _recursive_show(stream, object, current_depth, depth)

Generate a table of the field values of the `MLJType` object,
dislaying each value by calling the method `_show` on it. The
behaviour of `_show(stream, f)` is as follows:

1. If `f` is itself a `MLJType` object, then its short form is shown
and `_recursive_show` generates as separate table for each of its
field values (and so on, up to a depth of argument `depth`).

2. Otherwise `f` is displayed as "(omitted T)" where `T = typeof(f)`,
unless `istoobig(f)` is false (the `istoobig` fall-back for arbitrary
types being `true`). In the latter case, the long (ie,
MIME"plain/text") form of `f` is shown. To override this behaviour,
overload the `_show` method for the type in question. 

"""
function _recursive_show(stream::IO, object::MLJType, current_depth, depth)
    if depth == 0 || isempty(fieldnames(typeof(object)))
        println(stream, object)
    elseif current_depth <= depth 
        fields = fieldnames(typeof(object))
        print(stream, "#"^current_depth, " ")
        show(stream, object)
        println(stream, ": ")
#        println(stream)
        if isempty(fields)
            println(stream)
            return
        end
        for fld in fields
            fld_string = string(fld)*" "^(max(0,COLUMN_WIDTH - length(string(fld))))*"=>   "
            print(stream, fld_string)
            if isdefined(object, fld)
                _show(stream, getfield(object, fld))
                #           println(stream)
            else
                println(stream, "(undefined)")
                #           println(stream)
            end
        end
        println(stream)
        for fld in fields
            if isdefined(object, fld)
                subobject = getfield(object, fld)
                if isa(subobject, MLJType) && !isempty(fieldnames(typeof(subobject)))
                    _recursive_show(stream, getfield(object, fld),
                                    current_depth + 1, depth)
                end
            end
        end
    end
end



    


