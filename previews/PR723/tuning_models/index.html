<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tuning Models · MLJ</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="MLJ logo"/></a><div class="docs-package-name"><span class="docs-autofit">MLJ</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../getting_started/">Getting Started</a></li><li><a class="tocitem" href="../common_mlj_workflows/">Common MLJ Workflows</a></li><li><a class="tocitem" href="../working_with_categorical_data/">Working with Categorical Data</a></li><li><a class="tocitem" href="../model_search/">Model Search</a></li><li><a class="tocitem" href="../machines/">Machines</a></li><li><a class="tocitem" href="../evaluating_model_performance/">Evaluating Model Performance</a></li><li><a class="tocitem" href="../performance_measures/">Performance Measures</a></li><li class="is-active"><a class="tocitem" href>Tuning Models</a><ul class="internal"><li><a class="tocitem" href="#Tuning-a-single-hyperparameter-using-a-grid-search-1"><span>Tuning a single hyperparameter using a grid search</span></a></li><li><a class="tocitem" href="#Tuning-multiple-nested-hyperparameters-1"><span>Tuning multiple nested hyperparameters</span></a></li><li><a class="tocitem" href="#Tuning-using-a-random-search-1"><span>Tuning using a random search</span></a></li><li><a class="tocitem" href="#API-1"><span>API</span></a></li></ul></li><li><a class="tocitem" href="../learning_curves/">Learning Curves</a></li><li><a class="tocitem" href="../transformers/">Transformers and other unsupervised models</a></li><li><a class="tocitem" href="../composing_models/">Composing Models</a></li><li><a class="tocitem" href="../homogeneous_ensembles/">Homogeneous Ensembles</a></li><li><a class="tocitem" href="../generating_synthetic_data/">Generating Synthetic Data</a></li><li><a class="tocitem" href="../openml_integration/">OpenML Integration</a></li><li><a class="tocitem" href="../simple_user_defined_models/">Simple User Defined Models</a></li><li><a class="tocitem" href="../quick_start_guide_to_adding_models/">Quick-Start Guide to Adding Models</a></li><li><a class="tocitem" href="../adding_models_for_general_use/">Adding Models for General Use</a></li><li><a class="tocitem" href="../benchmarking/">Benchmarking</a></li><li><a class="tocitem" href="../internals/">Internals</a></li><li><a class="tocitem" href="../list_of_supported_models/">List of Supported Models</a></li><li><a class="tocitem" href="../glossary/">Glossary</a></li><li><a class="tocitem" href="../mlj_cheatsheet/">MLJ Cheatsheet</a></li><li><a class="tocitem" href="../frequently_asked_questions/">FAQ</a></li><li><a class="tocitem" href="../julia_blogpost/">Julia BlogPost</a></li><li><a class="tocitem" href="../acceleration_and_parallelism/">Acceleration and Parallelism</a></li><li><a class="tocitem" href="../api/">Index of Methods</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Tuning Models</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tuning Models</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/alan-turing-institute/MLJ.jl/blob/master/docs/src/tuning_models.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Tuning-models-1"><a class="docs-heading-anchor" href="#Tuning-models-1">Tuning models</a><a class="docs-heading-anchor-permalink" href="#Tuning-models-1" title="Permalink"></a></h1><p>Below we illustrate tuning model hyperparameters by grid and random searches. For a complete list of available and planned tuning strategies, see the <a href="https://github.com/alan-turing-institute/MLJTuning.jl#what-is-provided-here">MLJTuning page</a></p><p>In MLJ tuning is implemented as a model wrapper. After wrapping a model in a tuning strategy and binding the wrapped model to data in a machine, <code>mach</code>, calling <code>fit!(mach)</code> instigates a search for optimal model hyperparameters, within a specified <code>range</code>, and then uses all supplied data to train the best model. To predict using the optimal model, one just calls <code>predict(mach, Xnew)</code>. In this way the wrapped model may be viewed as a &quot;self-tuning&quot; version of the unwrapped model.</p><h2 id="Tuning-a-single-hyperparameter-using-a-grid-search-1"><a class="docs-heading-anchor" href="#Tuning-a-single-hyperparameter-using-a-grid-search-1">Tuning a single hyperparameter using a grid search</a><a class="docs-heading-anchor-permalink" href="#Tuning-a-single-hyperparameter-using-a-grid-search-1" title="Permalink"></a></h2><pre><code class="language-julia-repl">julia&gt; using MLJ

julia&gt; X = MLJ.table(rand(100, 10));

julia&gt; y = 2X.x1 - X.x2 + 0.05*rand(100);

julia&gt; tree_model = @load DecisionTreeRegressor;
[ Info: For silent loading, specify `verbosity=0`. 
import MLJDecisionTreeInterface ✔
const DecisionTreeRegressor = MLJDecisionTreeInterface.DecisionTreeRegressor ✔
DecisionTreeRegressor() ✔</code></pre><p>Let&#39;s tune <code>min_purity_increase</code> in the model above, using a grid-search. To do so we will use the simplest <code>range</code> object, a one-dimensional range object constructed using the <code>range</code> method:</p><pre><code class="language-julia-repl">julia&gt; r = range(tree_model, :min_purity_increase, lower=0.001, upper=1.0, scale=:log);

julia&gt; self_tuning_tree_model = TunedModel(model=tree_model,
                                           resampling = CV(nfolds=3),
                                           tuning = Grid(resolution=10),
                                           range = r,
                                           measure = rms);</code></pre><p>Incidentally, a grid is generated internally &quot;over the range&quot; by calling the <code>iterator</code> method with an appropriate resolution:</p><pre><code class="language-julia-repl">julia&gt; iterator(r, 5)
5-element Array{Float64,1}:
 0.0010000000000000002
 0.005623413251903492
 0.0316227766016838
 0.1778279410038923
 1.0</code></pre><p>Non-numeric hyperparameters are handled a little differently:</p><pre><code class="language-julia-repl">julia&gt; selector_model = FeatureSelector();

julia&gt; r2 = range(selector_model, :features, values = [[:x1,], [:x1, :x2]]);

julia&gt; iterator(r2)
2-element Array{Array{Symbol,1},1}:
 [:x1]
 [:x1, :x2]</code></pre><p>Unbounded ranges are also permitted. See the <code>range</code> and <code>iterator</code> docstrings below for details, and the <code>sampler</code> docstring for generating random samples from one-dimensional ranges (used internally by the <code>RandomSearch</code> strategy).</p><p>Returning to the wrapped tree model:</p><pre><code class="language-julia-repl">julia&gt; self_tuning_tree = machine(self_tuning_tree_model, X, y);

julia&gt; fit!(self_tuning_tree, verbosity=0);</code></pre><p>We can inspect the detailed results of the grid search with <code>report(self_tuning_tree)</code> or just retrieve the optimal model, as here:</p><pre><code class="language-julia-repl">julia&gt; fitted_params(self_tuning_tree).best_model
DecisionTreeRegressor(
    max_depth = -1,
    min_samples_leaf = 5,
    min_samples_split = 2,
    min_purity_increase = 0.0021544346900318843,
    n_subfeatures = 0,
    post_prune = false,
    merge_purity_threshold = 1.0) @320</code></pre><p>Predicting on new input observations using the optimal model:</p><pre><code class="language-julia-repl">julia&gt; Xnew  = MLJ.table(rand(3, 10));

julia&gt; predict(self_tuning_tree, Xnew)
3-element Array{Float64,1}:
 0.386527346398048
 1.1018971957571913
 0.386527346398048</code></pre><h2 id="Tuning-multiple-nested-hyperparameters-1"><a class="docs-heading-anchor" href="#Tuning-multiple-nested-hyperparameters-1">Tuning multiple nested hyperparameters</a><a class="docs-heading-anchor-permalink" href="#Tuning-multiple-nested-hyperparameters-1" title="Permalink"></a></h2><p>The following model has another model, namely a <code>DecisionTreeRegressor</code>, as a hyperparameter:</p><pre><code class="language-julia">julia&gt; tree_model = DecisionTreeRegressor()
julia&gt; forest_model = EnsembleModel(atom=tree_model);</code></pre><p>Ranges for nested hyperparameters are specified using dot syntax. In this case we will specify a <code>goal</code> for the total number of grid points:</p><pre><code class="language-julia-repl">julia&gt; r1 = range(forest_model, :(atom.n_subfeatures), lower=1, upper=9);

julia&gt; r2 = range(forest_model, :bagging_fraction, lower=0.4, upper=1.0);

julia&gt; self_tuning_forest_model = TunedModel(model=forest_model,
                                             tuning=Grid(goal=30),
                                             resampling=CV(nfolds=6),
                                             range=[r1, r2],
                                             measure=rms);

julia&gt; self_tuning_forest = machine(self_tuning_forest_model, X, y);

julia&gt; fit!(self_tuning_forest, verbosity=0)
Machine{DeterministicTunedModel{Grid,…}} @742 trained 1 time.
  args:
    1:	Source @061 ⏎ `Table{AbstractArray{Continuous,1}}`
    2:	Source @285 ⏎ `AbstractArray{Continuous,1}`</code></pre><p>In this two-parameter case, a plot of the grid search results is also available:</p><pre><code class="language-julia">using Plots
plot(self_tuning_forest)</code></pre><p><img src="../img/tuning_plot.png" alt/></p><p>Instead of specifying a <code>goal</code>, we can declare a global <code>resolution</code>, which is overriden for a particular parameter by pairing it&#39;s range with the resolution desired. In the next example, the default <code>resolution=100</code> is applied to the <code>r2</code> field, but a resolution of <code>3</code> is applied to the <code>r1</code> field. Additionally, we ask that the grid points be randomly traversed, and the the total number of evaluations be limited to 25.</p><pre><code class="language-julia-repl">julia&gt; tuning = Grid(resolution=100, shuffle=true, rng=1234)
Grid(
    goal = nothing,
    resolution = 100,
    shuffle = true,
    rng = Random.MersenneTwister(UInt32[0x000004d2], Random.DSFMT.DSFMT_state(Int32[-1393240018, 1073611148, 45497681, 1072875908, 436273599, 1073674613, -2043716458, 1073445557, -254908435, 1072827086  …  -599655111, 1073144102, 367655457, 1072985259, -1278750689, 1018350124, -597141475, 249849711, 382, 0]), [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], UInt128[0x00000000000000000000000000000000, 0x00000000000000000000000000000000, 0x00000000000000000000000000000000, 0x00000000000000000000000000000000, 0x00000000000000000000000000000000, 0x00000000000000000000000000000000, 0x00000000000000000000000000000000, 0x00000000000000000000000000000000, 0x00000000000000000000000000000000, 0x00000000000000000000000000000000  …  0x00000000000000000000000000000000, 0x00000000000000000000000000000000, 0x00000000000000000000000000000000, 0x00000000000000000000000000000000, 0x00000000000000000000000000000000, 0x00000000000000000000000000000000, 0x00000000000000000000000000000000, 0x00000000000000000000000000000000, 0x00000000000000000000000000000000, 0x00000000000000000000000000000000], 1002, 0)) @478

julia&gt; self_tuning_forest_model = TunedModel(model=forest_model,
                                             tuning=tuning,
                                             resampling=CV(nfolds=6),
                                             range=[(r1, 3), r2],
                                             measure=rms,
                                             n=25);

julia&gt; fit!(machine(self_tuning_forest_model, X, y), verbosity=0)
Machine{DeterministicTunedModel{Grid,…}} @684 trained 1 time.
  args:
    1:	Source @832 ⏎ `Table{AbstractArray{Continuous,1}}`
    2:	Source @117 ⏎ `AbstractArray{Continuous,1}`</code></pre><p>For more options for a grid search, see <a href="#MLJTuning.Grid"><code>Grid</code></a> below.</p><h2 id="Tuning-using-a-random-search-1"><a class="docs-heading-anchor" href="#Tuning-using-a-random-search-1">Tuning using a random search</a><a class="docs-heading-anchor-permalink" href="#Tuning-using-a-random-search-1" title="Permalink"></a></h2><p>Let&#39;s attempt to tune the same hyperparameters using a <code>RandomSearch</code> tuning strategy. By default, bounded numeric ranges like <code>r1</code> and <code>r2</code> are sampled uniformly (before rounding, in the case of the integer range <code>r1</code>). Positive unbounded ranges are sampled using a Gamma distribution by default, and all others using a (truncated) normal distribution.</p><pre><code class="language-julia-repl">julia&gt; self_tuning_forest_model = TunedModel(model=forest_model,
                                             tuning=RandomSearch(),
                                             resampling=CV(nfolds=6),
                                             range=[r1, r2],
                                             measure=rms,
                                             n=25);

julia&gt; self_tuning_forest = machine(self_tuning_forest_model, X, y);

julia&gt; fit!(self_tuning_forest, verbosity=0)
Machine{DeterministicTunedModel{RandomSearch,…}} @115 trained 1 time.
  args:
    1:	Source @333 ⏎ `Table{AbstractArray{Continuous,1}}`
    2:	Source @955 ⏎ `AbstractArray{Continuous,1}`</code></pre><pre><code class="language-julia">using Plots
plot(self_tuning_forest)</code></pre><p><img src="../img/random_search_tuning_plot.png" alt/></p><p>The prior distributions used for sampling each hyperparameter can be customized, as can the global fallbacks. See the <a href="#MLJTuning.RandomSearch"><code>RandomSearch</code></a> doc-string below for details.</p><h2 id="API-1"><a class="docs-heading-anchor" href="#API-1">API</a><a class="docs-heading-anchor-permalink" href="#API-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.range" href="#Base.range"><code>Base.range</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">r = range(model, :hyper; values=nothing)</code></pre><p>Define a one-dimensional <code>NominalRange</code> object for a field <code>hyper</code> of <code>model</code>. Note that <code>r</code> is not directly iterable but <code>iterator(r)</code> is.</p><p>A nested hyperparameter is specified using dot notation. For example, <code>:(atom.max_depth)</code> specifies the <code>max_depth</code> hyperparameter of the submodel <code>model.atom</code>.</p><pre><code class="language-none">r = range(model, :hyper; upper=nothing, lower=nothing,
          scale=nothing, values=nothing)</code></pre><p>Assuming <code>values</code> is not specified, define a one-dimensional <code>NumericRange</code> object for a <code>Real</code> field <code>hyper</code> of <code>model</code>.  Note that <code>r</code> is not directly iteratable but <code>iterator(r, n)</code>is an iterator of length <code>n</code>. To generate random elements from <code>r</code>, instead apply <code>rand</code> methods to <code>sampler(r)</code>. The supported scales are <code>:linear</code>,<code>:log</code>, <code>:logminus</code>, <code>:log10</code>, <code>:log2</code>, or a callable object.</p><p>Note that <code>r</code> is not directly iterable, but <code>iterator(r, n)</code> is, for given resolution (length) <code>n</code>.</p><p>By default, the behaviour of the constructed object depends on the type of the value of the hyperparameter <code>:hyper</code> at <code>model</code> <em>at the time of construction.</em> To override this behaviour (for instance if <code>model</code> is not available) specify a type in place of <code>model</code> so the behaviour is determined by the value of the specified type.</p><p>A nested hyperparameter is specified using dot notation (see above).</p><p>If <code>scale</code> is unspecified, it is set to <code>:linear</code>, <code>:log</code>, <code>:logminus</code>, or <code>:linear</code>, according to whether the interval <code>(lower, upper)</code> is bounded, right-unbounded, left-unbounded, or doubly unbounded, respectively.  Note <code>upper=Inf</code> and <code>lower=-Inf</code> are allowed.</p><p>If <code>values</code> is specified, the other keyword arguments are ignored and a <code>NominalRange</code> object is returned (see above).</p><p>See also: <a href="#MLJBase.iterator"><code>iterator</code></a>, <a href="#Distributions.sampler"><code>sampler</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.iterator" href="#MLJBase.iterator"><code>MLJBase.iterator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">iterator([rng, ], r::NominalRange, [,n])
iterator([rng, ], r::NumericRange, n)</code></pre><p>Return an iterator (currently a vector) for a <code>ParamRange</code> object <code>r</code>. In the first case iteration is over all <code>values</code> stored in the range (or just the first <code>n</code>, if <code>n</code> is specified). In the second case, the iteration is over approximately <code>n</code> ordered values, generated as follows:</p><p>(i) First, exactly <code>n</code> values are generated between <code>U</code> and <code>L</code>, with a spacing determined by <code>r.scale</code> (uniform if <code>scale=:linear</code>) where <code>U</code> and <code>L</code> are given by the following table:</p><table><tr><th style="text-align: right"><code>r.lower</code></th><th style="text-align: right"><code>r.upper</code></th><th style="text-align: right"><code>L</code></th><th style="text-align: right"><code>U</code></th></tr><tr><td style="text-align: right">finite</td><td style="text-align: right">finite</td><td style="text-align: right"><code>r.lower</code></td><td style="text-align: right"><code>r.upper</code></td></tr><tr><td style="text-align: right"><code>-Inf</code></td><td style="text-align: right">finite</td><td style="text-align: right"><code>r.upper - 2r.unit</code></td><td style="text-align: right"><code>r.upper</code></td></tr><tr><td style="text-align: right">finite</td><td style="text-align: right"><code>Inf</code></td><td style="text-align: right"><code>r.lower</code></td><td style="text-align: right"><code>r.lower + 2r.unit</code></td></tr><tr><td style="text-align: right"><code>-Inf</code></td><td style="text-align: right"><code>Inf</code></td><td style="text-align: right"><code>r.origin - r.unit</code></td><td style="text-align: right"><code>r.origin + r.unit</code></td></tr></table><p>(ii) If a callable <code>f</code> is provided as <code>scale</code>, then a uniform spacing is always applied in (i) but <code>f</code> is broadcast over the results. (Unlike ordinary scales, this alters the effective range of values generated, instead of just altering the spacing.)</p><p>(iii) If <code>r</code> is a discrete numeric range (<code>r isa NumericRange{&lt;:Integer}</code>) then the values are additionally rounded, with any duplicate values removed. Otherwise all the values are used (and there are exacltly <code>n</code> of them).</p><p>(iv) Finally, if a random number generator <code>rng</code> is specified, then the values are returned in random order (sampling without replacement), and otherwise they are returned in numeric order, or in the order provided to the range constructor, in the case of a <code>NominalRange</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Distributions.sampler" href="#Distributions.sampler"><code>Distributions.sampler</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sampler(r::NominalRange, probs::AbstractVector{&lt;:Real})
sampler(r::NominalRange)
sampler(r::NumericRange{T}, d)</code></pre><p>Construct an object <code>s</code> which can be used to generate random samples from a <code>ParamRange</code> object <code>r</code> (a one-dimensional range) using one of the following calls:</p><pre><code class="language-none">rand(s)             # for one sample
rand(s, n)          # for n samples
rand(rng, s [, n])  # to specify an RNG</code></pre><p>The argument <code>probs</code> can be any probability vector with the same length as <code>r.values</code>. The second <code>sampler</code> method above calls the first with a uniform <code>probs</code> vector.</p><p>The argument <code>d</code> can be either an arbitrary instance of <code>UnivariateDistribution</code> from the Distributions.jl package, or one of a Distributions.jl <em>types</em> for which <code>fit(d, ::NumericRange)</code> is defined. These include: <code>Arcsine</code>, <code>Uniform</code>, <code>Biweight</code>, <code>Cosine</code>, <code>Epanechnikov</code>, <code>SymTriangularDist</code>, <code>Triweight</code>, <code>Normal</code>, <code>Gamma</code>, <code>InverseGaussian</code>, <code>Logistic</code>, <code>LogNormal</code>, <code>Cauchy</code>, <code>Gumbel</code>, <code>Laplace</code>, and <code>Poisson</code>; but see the doc-string for <a href="#StatsBase.fit-Union{Tuple{D}, Tuple{Type{D},MLJBase.NumericRange}} where D&lt;:Distributions.Distribution"><code>Distributions.fit</code></a> for an up-to-date list.</p><p>If <code>d</code> is an <em>instance</em>, then sampling is from a truncated form of the supplied distribution <code>d</code>, the truncation bounds being <code>r.lower</code> and <code>r.upper</code> (the attributes <code>r.origin</code> and <code>r.unit</code> attributes are ignored). For discrete numeric ranges (<code>T &lt;: Integer</code>) the samples are rounded.</p><p>If <code>d</code> is a <em>type</em> then a suitably truncated distribution is automatically generated using <code>Distributions.fit(d, r)</code>.</p><p><em>Important.</em> Values are generated with no regard to <code>r.scale</code>, except in the special case <code>r.scale</code> is a callable object <code>f</code>. In that case, <code>f</code> is applied to all values generated by <code>rand</code> as described above (prior to rounding, in the case of discrete numeric ranges).</p><p><strong>Examples</strong></p><pre><code class="language-none">r = range(Char, :letter, values=collect(&quot;abc&quot;))
s = sampler(r, [0.1, 0.2, 0.7])
samples =  rand(s, 1000);
StatsBase.countmap(samples)
Dict{Char,Int64} with 3 entries:
  &#39;a&#39; =&gt; 107
  &#39;b&#39; =&gt; 205
  &#39;c&#39; =&gt; 688

r = range(Int, :k, lower=2, upper=6) # numeric but discrete
s = sampler(r, Normal)
samples = rand(s, 1000);
UnicodePlots.histogram(samples)
           ┌                                        ┐
[2.0, 2.5) ┤▇▇▇▇▇▇▇▇▇▇▇▇▇▇ 119
[2.5, 3.0) ┤ 0
[3.0, 3.5) ┤▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇ 296
[3.5, 4.0) ┤ 0
[4.0, 4.5) ┤▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇ 275
[4.5, 5.0) ┤ 0
[5.0, 5.5) ┤▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇ 221
[5.5, 6.0) ┤ 0
[6.0, 6.5) ┤▇▇▇▇▇▇▇▇▇▇▇ 89
           └                                        ┘</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.fit-Union{Tuple{D}, Tuple{Type{D},MLJBase.NumericRange}} where D&lt;:Distributions.Distribution" href="#StatsBase.fit-Union{Tuple{D}, Tuple{Type{D},MLJBase.NumericRange}} where D&lt;:Distributions.Distribution"><code>StatsBase.fit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Distributions.fit(D, r::MLJBase.NumericRange)</code></pre><p>Fit and return a distribution <code>d</code> of type <code>D</code> to the one-dimensional range <code>r</code>.</p><p>Only types <code>D</code> in the table below are supported.</p><p>The distribution <code>d</code> is constructed in two stages. First, a distributon <code>d0</code>, characterized by the conditions in the second column of the table, is fit to <code>r</code>. Then <code>d0</code> is truncated between <code>r.lower</code> and <code>r.upper</code> to obtain <code>d</code>.</p><table><tr><th style="text-align: left">Distribution type <code>D</code></th><th style="text-align: left">Characterization of <code>d0</code></th></tr><tr><td style="text-align: left"><code>Arcsine</code>, <code>Uniform</code>, <code>Biweight</code>, <code>Cosine</code>, <code>Epanechnikov</code>, <code>SymTriangularDist</code>, <code>Triweight</code></td><td style="text-align: left"><code>minimum(d) = r.lower</code>, <code>maximum(d) = r.upper</code></td></tr><tr><td style="text-align: left"><code>Normal</code>, <code>Gamma</code>, <code>InverseGaussian</code>, <code>Logistic</code>, <code>LogNormal</code></td><td style="text-align: left"><code>mean(d) = r.origin</code>, <code>std(d) = r.unit</code></td></tr><tr><td style="text-align: left"><code>Cauchy</code>, <code>Gumbel</code>, <code>Laplace</code>, (<code>Normal</code>)</td><td style="text-align: left"><code>Dist.location(d) = r.origin</code>, <code>Dist.scale(d)  = r.unit</code></td></tr><tr><td style="text-align: left"><code>Poisson</code></td><td style="text-align: left"><code>Dist.mean(d) = r.unit</code></td></tr></table><p>Here <code>Dist = Distributions</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJTuning.TunedModel" href="#MLJTuning.TunedModel"><code>MLJTuning.TunedModel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">tuned_model = TunedModel(; model=nothing,
                         tuning=Grid(),
                         resampling=Holdout(),
                         measure=nothing,
                         weights=nothing,
                         repeats=1,
                         operation=predict,
                         range=nothing,
                         selection_heuristic=NaiveSelection(),
                         n=default_n(tuning, range),
                         train_best=true,
                         acceleration=default_resource(),
                         acceleration_resampling=CPU1(),
                         check_measure=true)</code></pre><p>Construct a model wrapper for hyperparameter optimization of a supervised learner.</p><p>Calling <code>fit!(mach)</code> on a machine <code>mach=machine(tuned_model, X, y)</code> or <code>mach=machine(tuned_model, X, y, w)</code> will:</p><ul><li><p>Instigate a search, over clones of <code>model</code>, with the hyperparameter mutations specified by <code>range</code>, for a model optimizing the specified <code>measure</code>, using performance evaluations carried out using the specified <code>tuning</code> strategy and <code>resampling</code> strategy.</p></li><li><p>Fit an internal machine, based on the optimal model <code>fitted_params(mach).best_model</code>, wrapping the optimal <code>model</code> object in <em>all</em> the provided data <code>X</code>, <code>y</code>(, <code>w</code>). Calling <code>predict(mach, Xnew)</code> then returns predictions on <code>Xnew</code> of this internal machine. The final train can be supressed by setting <code>train_best=false</code>.</p></li></ul><p>The <code>range</code> objects supported depend on the <code>tuning</code> strategy specified. Query the <code>strategy</code> docstring for details. To optimize over an explicit list <code>v</code> of models of the same type, use <code>strategy=Explicit()</code> and specify <code>model=v[1]</code> and <code>range=v</code>.</p><p>The number of models searched is specified by <code>n</code>. If unspecified, then <code>MLJTuning.default_n(tuning, range)</code> is used. When <code>n</code> is increased and <code>fit!(mach)</code> called again, the old search history is re-instated and the search continues where it left off.</p><p>If <code>measure</code> supports weights (<code>supports_weights(measure) == true</code>) then any <code>weights</code> specified will be passed to the measure. If more than one <code>measure</code> is specified, then only the first is optimized (unless <code>strategy</code> is multi-objective) but the performance against every measure specified will be computed and reported in <code>report(mach).best_performance</code> and other relevant attributes of the generated report.</p><p>Specify <code>repeats &gt; 1</code> for repeated resampling per model evaluation. See <a href="../evaluating_model_performance/#MLJBase.evaluate!"><code>evaluate!</code></a> options for details.</p><p><em>Important.</em> If a custom <code>measure</code> is used, and the measure is a score, rather than a loss, be sure to check that <code>MLJ.orientation(measure) == :score</code> to ensure maximization of the measure, rather than minimization. Override an incorrect value with <code>MLJ.orientation(::typeof(measure)) = :score</code>.</p><p>In the case of two-parameter tuning, a Plots.jl plot of performance estimates is returned by <code>plot(mach)</code> or <code>heatmap(mach)</code>.</p><p>Once a tuning machine <code>mach</code> has bee trained as above, then <code>fitted_params(mach)</code> has these keys/values:</p><table><tr><th style="text-align: right">key</th><th style="text-align: right">value</th></tr><tr><td style="text-align: right"><code>best_model</code></td><td style="text-align: right">optimal model instance</td></tr><tr><td style="text-align: right"><code>best_fitted_params</code></td><td style="text-align: right">learned parameters of the optimal model</td></tr></table><p>The named tuple <code>report(mach)</code> includes these keys/values:</p><table><tr><th style="text-align: right">key</th><th style="text-align: right">value</th></tr><tr><td style="text-align: right"><code>best_model</code></td><td style="text-align: right">optimal model instance</td></tr><tr><td style="text-align: right"><code>best_history_entry</code></td><td style="text-align: right">corresponding entry in the history, including performance estimate</td></tr><tr><td style="text-align: right"><code>best_report</code></td><td style="text-align: right">report generated by fitting the optimal model to all data</td></tr><tr><td style="text-align: right"><code>history</code></td><td style="text-align: right">tuning strategy-specific history of all evaluations</td></tr></table><p>plus other key/value pairs specific to the <code>tuning</code> strategy.</p><p><strong>Summary of key-word arguments</strong></p><ul><li><p><code>model</code>: <code>Supervised</code> model prototype that is cloned and mutated to generate models for evaluation</p></li><li><p><code>tuning=Grid()</code>: tuning strategy to be applied (eg, <code>RandomSearch()</code>)</p></li><li><p><code>resampling=Holdout()</code>: resampling strategy (eg, <code>Holdout()</code>, <code>CV()</code>), <code>StratifiedCV()</code>) to be applied in performance evaluations</p></li><li><p><code>measure</code>: measure or measures to be applied in performance evaluations; only the first used in optimization (unless the strategy is multi-objective) but all reported to the history</p></li><li><p><code>weights</code>: sample weights to be passed the measure(s) in performance evaluations, if supported.</p></li><li><p><code>repeats=1</code>: for generating train/test sets multiple times in resampling; see <a href="../evaluating_model_performance/#MLJBase.evaluate!"><code>evaluate!</code></a> for details</p></li><li><p><code>operation=predict</code>: operation to be applied to each fitted model; usually <code>predict</code> but <code>predict_mean</code>, <code>predict_median</code> or <code>predict_mode</code> can be used for <code>Probabilistic</code> models, if the specified measures are <code>Deterministic</code></p></li><li><p><code>range</code>: range object; tuning strategy documentation describes supported types</p></li><li><p><code>selection_heuristic</code>: the rule determining how the best model is decided. According to the default heuristic, <code>NaiveSelection()</code>, <code>measure</code> (or the first element of <code>measure</code>) is evaluated for each resample and these per-fold measurements are aggregrated. The model with the lowest (resp. highest) aggregate is chosen if the measure is a <code>:loss</code> (resp. a <code>:score</code>).</p></li><li><p><code>n</code>: number of iterations (ie, models to be evaluated); set by tuning strategy if left unspecified</p></li><li><p><code>train_best=true</code>: whether to train the optimal model</p></li><li><p><code>acceleration=default_resource()</code>: mode of parallelization for tuning strategies that support this</p></li><li><p><code>acceleration_resampling=CPU1()</code>: mode of parallelization for resampling</p></li><li><p><code>check_measure</code>: whether to check <code>measure</code> is compatible with the specified <code>model</code> and <code>operation</code>)</p></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJTuning.Grid" href="#MLJTuning.Grid"><code>MLJTuning.Grid</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Grid(goal=nothing, resolution=10, rng=Random.GLOBAL_RNG, shuffle=true)</code></pre><p>Instantiate a Cartesian grid-based hyperparameter tuning strategy with a specified number of grid points as <code>goal</code>, or using a specified default <code>resolution</code> in each numeric dimension.</p><p><strong>Supported ranges:</strong></p><p>A single one-dimensional range or vector of one-dimensioinal ranges can be specified. Specifically, in <code>Grid</code> search, the <code>range</code> field of a <code>TunedModel</code> instance can be:</p><ul><li><p>A single one-dimensional range - ie, <code>ParamRange</code> object - <code>r</code>, or pair of the form <code>(r, res)</code> where <code>res</code> specifies a resolution to override the default <code>resolution</code>.</p></li><li><p>Any vector of objects of the above form</p></li></ul><p>Two elements of a <code>range</code> vector may share the same <code>field</code> attribute, with the effect that their grids are combined, as in Example 3 below.</p><p><code>ParamRange</code> objects are constructed using the <code>range</code> method.</p><p>Example 1:</p><pre><code class="language-none">range(model, :hyper1, lower=1, origin=2, unit=1)</code></pre><p>Example 2:</p><pre><code class="language-none">[(range(model, :hyper1, lower=1, upper=10), 15),
  range(model, :hyper2, lower=2, upper=4),
  range(model, :hyper3, values=[:ball, :tree])]</code></pre><p>Example 3:</p><pre><code class="language-none"># a range generating the grid `[1, 2, 10, 20, 30]` for `:hyper1`:
[range(model, :hyper1, values=[1, 2]),
 (range(model, :hyper1, lower= 10, upper=30), 3)]</code></pre><p>Note: All the <code>field</code> values of the <code>ParamRange</code> objects (<code>:hyper1</code>, <code>:hyper2</code>, <code>:hyper3</code> in the preceding example) must refer to field names a of single model (the <code>model</code> specified during <code>TunedModel</code> construction).</p><p><strong>Algorithm</strong></p><p>This is a standard grid search with the following specifics: In all cases all <code>values</code> of each specified <code>NominalRange</code> are exhausted. If <code>goal</code> is specified, then all resolutions are ignored, and a global resolution is applied to the <code>NumericRange</code> objects that maximizes the number of grid points, subject to the restriction that this not exceed <code>goal</code>. (This assumes no field appears twice in the <code>range</code> vector.) Otherwise the default <code>resolution</code> and any parameter-specific resolutions apply.</p><p>In all cases the models generated are shuffled using <code>rng</code>, unless <code>shuffle=false</code>.</p><p>See also <a href="#MLJTuning.TunedModel"><code>TunedModel</code></a>, <a href="#Base.range"><code>range</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJTuning.RandomSearch" href="#MLJTuning.RandomSearch"><code>MLJTuning.RandomSearch</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RandomSearch(bounded=Distributions.Uniform,
             positive_unbounded=Distributions.Gamma,
             other=Distributions.Normal,
             rng=Random.GLOBAL_RNG)</code></pre><p>Instantiate a random search tuning strategy, for searching over Cartesian hyperparameter domains, with customizable priors in each dimension.</p><p><strong>Supported ranges</strong></p><p>A single one-dimensional range or vector of one-dimensioinal ranges can be specified. If not paired with a prior, then one is fitted, according to fallback distribution types specified by the tuning strategy hyperparameters. Specifically, in <code>RandomSearch</code>, the <code>range</code> field of a <code>TunedModel</code> instance can be:</p><ul><li><p>a single one-dimensional range (<code>ParamRange</code> object) <code>r</code></p></li><li><p>a pair of the form <code>(r, d)</code>, with <code>r</code> as above and where <code>d</code> is:</p><ul><li><p>a probability vector of the same length as <code>r.values</code> (<code>r</code> a <code>NominalRange</code>)</p></li><li><p>any <code>Distributions.UnivariateDistribution</code> <em>instance</em> (<code>r</code> a <code>NumericRange</code>)</p></li><li><p>one of the <em>subtypes</em> of <code>Distributions.UnivariateDistribution</code> listed in the table below, for automatic fitting using <code>Distributions.fit(d, r)</code>, a distribution whose support always lies between <code>r.lower</code> and <code>r.upper</code> (<code>r</code> a <code>NumericRange</code>)</p></li></ul></li><li><p>any pair of the form <code>(field, s)</code>, where <code>field</code> is the (possibly nested) name of a field of the model to be tuned, and <code>s</code> an arbitrary sampler object for that field. This means only that <code>rand(rng, s)</code> is defined and returns valid values for the field.</p></li><li><p>any vector of objects of the above form</p></li></ul><p>A range vector may contain multiple entries for the same model field, as in <code>range = [(:lambda, s1), (:alpha, s), (:lambda, s2)]</code>. In that case the entry used in each iteration is random.</p><table><tr><th style="text-align: right">distribution types</th><th style="text-align: right">for fitting to ranges of this type</th></tr><tr><td style="text-align: right"><code>Arcsine</code>, <code>Uniform</code>, <code>Biweight</code>, <code>Cosine</code>, <code>Epanechnikov</code>, <code>SymTriangularDist</code>, <code>Triweight</code></td><td style="text-align: right">bounded</td></tr><tr><td style="text-align: right"><code>Gamma</code>, <code>InverseGaussian</code>, <code>Poisson</code></td><td style="text-align: right">positive (bounded or unbounded)</td></tr><tr><td style="text-align: right"><code>Normal</code>, <code>Logistic</code>, <code>LogNormal</code>, <code>Cauchy</code>, <code>Gumbel</code>, <code>Laplace</code></td><td style="text-align: right">any</td></tr></table><p><code>ParamRange</code> objects are constructed using the <code>range</code> method.</p><p><strong>Examples</strong></p><pre><code class="language-none">using Distributions

range1 = range(model, :hyper1, lower=0, upper=1)

range2 = [(range(model, :hyper1, lower=1, upper=10), Arcsine),
          range(model, :hyper2, lower=2, upper=Inf, unit=1, origin=3),
          (range(model, :hyper2, lower=2, upper=4), Normal(0, 3)),
          (range(model, :hyper3, values=[:ball, :tree]), [0.3, 0.7])]

# uniform sampling of :(atom.λ) from [0, 1] without defining a NumericRange:
struct MySampler end
Base.rand(rng::Random.AbstractRNG, ::MySampler) = rand(rng)
range3 = (:(atom.λ), MySampler())</code></pre><p><strong>Algorithm</strong></p><p>In each iteration, a model is generated for evaluation by mutating the fields of a deep copy of <code>model</code>. The range vector is shuffled and the fields sampled according to the new order (repeated fields being mutated more than once). For a <code>range</code> entry of the form <code>(field, s)</code> the algorithm calls <code>rand(rng, s)</code> and mutates the field <code>field</code> of the model clone to have this value. For an entry of the form <code>(r, d)</code>, <code>s</code> is substituted with <code>sampler(r, d)</code>. If no <code>d</code> is specified, then sampling is uniform (with replacement) if <code>r</code> is a <code>NominalRange</code>, and is otherwise given by the defaults specified by the tuning strategy parameters <code>bounded</code>, <code>positive_unbounded</code>, and <code>other</code>, depending on the field values of the <code>NumericRange</code> object <code>r</code>.</p><p>See also <a href="#MLJTuning.TunedModel"><code>TunedModel</code></a>, <a href="#Base.range"><code>range</code></a>, <a href="#Distributions.sampler"><code>sampler</code></a>.</p></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../performance_measures/">« Performance Measures</a><a class="docs-footer-nextpage" href="../learning_curves/">Learning Curves »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 13 December 2020 04:02">Sunday 13 December 2020</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
