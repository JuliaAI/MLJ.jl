<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Preparing Data · MLJ</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="MLJ logo"/></a><div class="docs-package-name"><span class="docs-autofit">MLJ</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../about_mlj/">About MLJ</a></li><li><a class="tocitem" href="../learning_mlj/">Learning MLJ</a></li><li><a class="tocitem" href="../getting_started/">Getting Started</a></li><li><a class="tocitem" href="../common_mlj_workflows/">Common MLJ Workflows</a></li><li><a class="tocitem" href="../working_with_categorical_data/">Working with Categorical Data</a></li><li><a class="tocitem" href="../model_search/">Model Search</a></li><li><a class="tocitem" href="../loading_model_code/">Loading Model Code</a></li><li><a class="tocitem" href="../machines/">Machines</a></li><li><a class="tocitem" href="../evaluating_model_performance/">Evaluating Model Performance</a></li><li><a class="tocitem" href="../performance_measures/">Performance Measures</a></li><li><a class="tocitem" href="../weights/">Weights</a></li><li><a class="tocitem" href="../tuning_models/">Tuning Models</a></li><li><a class="tocitem" href="../learning_curves/">Learning Curves</a></li><li class="is-active"><a class="tocitem" href>Preparing Data</a><ul class="internal"><li><a class="tocitem" href="#Splitting-data"><span>Splitting data</span></a></li><li><a class="tocitem" href="#Bridging-the-gap-between-data-type-and-model-requirements"><span>Bridging the gap between data type and model requirements</span></a></li><li><a class="tocitem" href="#Scientific-type-coercion"><span>Scientific type coercion</span></a></li><li><a class="tocitem" href="#Data-transformation"><span>Data transformation</span></a></li></ul></li><li><a class="tocitem" href="../transformers/">Transformers and Other Unsupervised models</a></li><li><a class="tocitem" href="../more_on_probabilistic_predictors/">More on Probablistic Predictors</a></li><li><a class="tocitem" href="../composing_models/">Composing Models</a></li><li><a class="tocitem" href="../linear_pipelines/">Linear Pipelines</a></li><li><a class="tocitem" href="../target_transformations/">Target Transformations</a></li><li><a class="tocitem" href="../homogeneous_ensembles/">Homogeneous Ensembles</a></li><li><a class="tocitem" href="../model_stacking/">Model Stacking</a></li><li><a class="tocitem" href="../controlling_iterative_models/">Controlling Iterative Models</a></li><li><a class="tocitem" href="../generating_synthetic_data/">Generating Synthetic Data</a></li><li><a class="tocitem" href="../openml_integration/">OpenML Integration</a></li><li><a class="tocitem" href="../acceleration_and_parallelism/">Acceleration and Parallelism</a></li><li><a class="tocitem" href="../simple_user_defined_models/">Simple User Defined Models</a></li><li><a class="tocitem" href="../quick_start_guide_to_adding_models/">Quick-Start Guide to Adding Models</a></li><li><a class="tocitem" href="../adding_models_for_general_use/">Adding Models for General Use</a></li><li><a class="tocitem" href="../modifying_behavior/">Modifying Behavior</a></li><li><a class="tocitem" href="../internals/">Internals</a></li><li><a class="tocitem" href="../list_of_supported_models/">List of Supported Models</a></li><li><a class="tocitem" href="../third_party_packages/">Third Party Packages</a></li><li><a class="tocitem" href="../glossary/">Glossary</a></li><li><a class="tocitem" href="../mlj_cheatsheet/">MLJ Cheatsheet</a></li><li><a class="tocitem" href="../known_issues/">Known Issues</a></li><li><a class="tocitem" href="../frequently_asked_questions/">FAQ</a></li><li><a class="tocitem" href="../julia_blogpost/">Julia BlogPost</a></li><li><a class="tocitem" href="../api/">Index of Methods</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Preparing Data</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Preparing Data</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/alan-turing-institute/MLJ.jl/blob/master/docs/src/preparing_data.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Preparing-Data"><a class="docs-heading-anchor" href="#Preparing-Data">Preparing Data</a><a id="Preparing-Data-1"></a><a class="docs-heading-anchor-permalink" href="#Preparing-Data" title="Permalink"></a></h1><h2 id="Splitting-data"><a class="docs-heading-anchor" href="#Splitting-data">Splitting data</a><a id="Splitting-data-1"></a><a class="docs-heading-anchor-permalink" href="#Splitting-data" title="Permalink"></a></h2><p>MLJ has two tools for splitting data. To split data <em>vertically</em> (that is, to split by observations) use <a href="#MLJBase.partition"><code>partition</code></a>. This is commonly applied to a vector of observation <em>indices</em>, but can also be applied to datasets themselves, provided they are vectors, matrices or tables.</p><p>To split tabular data <em>horizontally</em> (i.e., break up a table based on feature names) use <a href="#MLJBase.unpack"><code>unpack</code></a>.</p><article class="docstring"><header><a class="docstring-binding" id="MLJBase.partition" href="#MLJBase.partition"><code>MLJBase.partition</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">partition(X, fractions...;
          shuffle=nothing,
          rng=Random.GLOBAL_RNG,
          stratify=nothing,
          multi=false)</code></pre><p>Splits the vector, matrix or table <code>X</code> into a tuple of objects of the same type, whose vertical concatenation is <code>X</code>. The number of rows in each component of the return value is determined by the corresponding <code>fractions</code> of <code>length(nrows(X))</code>, where valid fractions are floats between 0 and 1 whose sum is less than one. The last fraction is not provided, as it is inferred from the preceding ones.</p><p>For &quot;synchronized&quot; partitioning of multiple objects, use the <code>multi=true</code> option described below.</p><pre><code class="language-none">julia&gt; partition(1:1000, 0.8)
([1,...,800], [801,...,1000])

julia&gt; partition(1:1000, 0.2, 0.7)
([1,...,200], [201,...,900], [901,...,1000])

julia&gt; partition(reshape(1:10, 5, 2), 0.2, 0.4)
([1 6], [2 7; 3 8], [4 9; 5 10])

X, y = make_blobs() # a table and vector
Xtrain, Xtest = partition(X, 0.8, stratify=y)

(Xtrain, Xtest), (ytrain, ytest) = partition((X, y), 0.8, rng=123, multi=true)</code></pre><p><strong>Keywords</strong></p><ul><li><p><code>shuffle=nothing</code>: if set to <code>true</code>, shuffles the rows before taking fractions.</p></li><li><p><code>rng=Random.GLOBAL_RNG</code>: specifies the random number generator to be used, can be an integer seed. If specified, and <code>shuffle === nothing</code> is interpreted as true.</p></li><li><p><code>stratify=nothing</code>: if a vector is specified, the partition will match the stratification of the given vector. In that case, <code>shuffle</code> cannot be <code>false</code>.</p></li><li><p><code>multi=false</code>: if <code>true</code> then <code>X</code> is expected to be a <code>tuple</code> of objects sharing a common length, which are each partitioned separately using the same specified <code>fractions</code> <em>and</em> the same row shuffling. Returns a tuple of partitions (a tuple of tuples).</p></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.unpack" href="#MLJBase.unpack"><code>MLJBase.unpack</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">unpack(table, f1, f2, ... fk;
       wrap_singles=false,
       shuffle=false,
       rng::Union{AbstractRNG,Int,Nothing}=nothing,
       coerce_options...)</code></pre><p>Horizontally split any Tables.jl compatible <code>table</code> into smaller tables or vectors by making column selections determined by the predicates <code>f1</code>, <code>f2</code>, ..., <code>fk</code>. Selection from the column names is without replacement. A <em>predicate</em> is any object <code>f</code> such that <code>f(name)</code> is <code>true</code> or <code>false</code> for each column <code>name::Symbol</code> of <code>table</code>.</p><p>Returns a tuple of tables/vectors with length one greater than the number of supplied predicates, with the last component including all previously unselected columns.</p><pre><code class="language-none">julia&gt; table = DataFrame(x=[1,2], y=[&#39;a&#39;, &#39;b&#39;], z=[10.0, 20.0], w=[&quot;A&quot;, &quot;B&quot;])
2×4 DataFrame
 Row │ x      y     z        w
     │ Int64  Char  Float64  String
─────┼──────────────────────────────
   1 │     1  a        10.0  A
   2 │     2  b        20.0  B

Z, XY, W = unpack(table, ==(:z), !=(:w))
julia&gt; Z
2-element Vector{Float64}:
 10.0
 20.0

julia&gt; XY
2×2 DataFrame
 Row │ x      y
     │ Int64  Char
─────┼─────────────
   1 │     1  a
   2 │     2  b

julia&gt; W  # the column(s) left over
2-element Vector{String}:
 &quot;A&quot;
 &quot;B&quot;</code></pre><p>Whenever a returned table contains a single column, it is converted to a vector unless <code>wrap_singles=true</code>.</p><p>If <code>coerce_options</code> are specified then <code>table</code> is first replaced with <code>coerce(table, coerce_options)</code>. See <a href="../getting_started/#ScientificTypes.coerce"><code>ScientificTypes.coerce</code></a> for details.</p><p>If <code>shuffle=true</code> then the rows of <code>table</code> are first shuffled, using the global RNG, unless <code>rng</code> is specified; if <code>rng</code> is an integer, it specifies the seed of an automatically generated Mersenne twister. If <code>rng</code> is specified then <code>shuffle=true</code> is implicit.</p></div></section></article><h2 id="Bridging-the-gap-between-data-type-and-model-requirements"><a class="docs-heading-anchor" href="#Bridging-the-gap-between-data-type-and-model-requirements">Bridging the gap between data type and model requirements</a><a id="Bridging-the-gap-between-data-type-and-model-requirements-1"></a><a class="docs-heading-anchor-permalink" href="#Bridging-the-gap-between-data-type-and-model-requirements" title="Permalink"></a></h2><p>As outlined in <a href="../getting_started/#Getting-Started">Getting Started</a>, it is important that the <a href="https://github.com/JuliaAI/ScientificTypesBase.jl">scientific type</a> of data matches the requirements of the model of interest. For example, while the majority of supervised learning models require input features to be <code>Continuous</code>, newcomers to MLJ are sometimes surprised at the disappointing results of <a href="../model_search/#model_search">model queries</a> such as this one:</p><pre><code class="language-julia">X = (height   = [185, 153, 163, 114, 180],
     time     = [2.3, 4.5, 4.2, 1.8, 7.1],
     mark     = [&quot;D&quot;, &quot;A&quot;, &quot;C&quot;, &quot;B&quot;, &quot;A&quot;],
     admitted = [&quot;yes&quot;, &quot;no&quot;, missing, &quot;yes&quot;]);
y = [12.4, 12.5, 12.0, 31.9, 43.0]
models(matching(X, y))</code></pre><pre class="documenter-example-output">4-element Vector{NamedTuple{(:name, :package_name, :is_supervised, :abstract_type, :deep_properties, :docstring, :fit_data_scitype, :human_name, :hyperparameter_ranges, :hyperparameter_types, :hyperparameters, :implemented_methods, :inverse_transform_scitype, :is_pure_julia, :is_wrapper, :iteration_parameter, :load_path, :package_license, :package_url, :package_uuid, :predict_scitype, :prediction_type, :supports_class_weights, :supports_online, :supports_training_losses, :supports_weights, :transform_scitype, :input_scitype, :target_scitype, :output_scitype)}}:
 (name = ConstantRegressor, package_name = MLJModels, ... )
 (name = DecisionTreeRegressor, package_name = BetaML, ... )
 (name = DeterministicConstantRegressor, package_name = MLJModels, ... )
 (name = RandomForestRegressor, package_name = BetaML, ... )</pre><p>Or are unsure about the source of the following warning:</p><pre><code class="language-julia">Tree = @load DecisionTreeRegressor pkg=DecisionTree verbosity=0
tree = Tree();
julia&gt; machine(tree, X, y)

julia&gt; machine(tree, X, y)
┌ Warning: The scitype of `X`, in `machine(model, X, ...)` is incompatible with `model=DecisionTreeRegressor @378`:                                                                
│ scitype(X) = Table{Union{AbstractVector{Continuous}, AbstractVector{Count}, AbstractVector{Textual}, AbstractVector{Union{Missing, Textual}}}}
│ input_scitype(model) = Table{var&quot;#s46&quot;} where var&quot;#s46&quot;&lt;:Union{AbstractVector{var&quot;#s9&quot;} where var&quot;#s9&quot;&lt;:Continuous, AbstractVector{var&quot;#s9&quot;} where var&quot;#s9&quot;&lt;:Count, AbstractVector{var&quot;#s9&quot;} where var&quot;#s9&quot;&lt;:OrderedFactor}.
└ @ MLJBase ~/Dropbox/Julia7/MLJ/MLJBase/src/machines.jl:103
Machine{DecisionTreeRegressor,…} @198 trained 0 times; caches data
  args: 
    1:  Source @628 ⏎ `Table{Union{AbstractVector{Continuous}, AbstractVector{Count}, AbstractVector{Textual}, AbstractVector{Union{Missing, Textual}}}}`
    2:  Source @544 ⏎ `AbstractVector{Continuous}`</code></pre><p>The meaning of the warning is:</p><ul><li>The input <code>X</code> is a table with column scitypes <code>Continuous</code>, <code>Count</code>, and <code>Textual</code> and <code>Union{Missing, Textual}</code>, which can also see by inspecting the schema:</li></ul><pre><code class="language-julia">schema(X)</code></pre><pre class="documenter-example-output">┌──────────┬─────────────────────────┬────────────────────────┐
│ names    │ scitypes                │ types                  │
├──────────┼─────────────────────────┼────────────────────────┤
│ height   │ Count                   │ Int64                  │
│ time     │ Continuous              │ Float64                │
│ mark     │ Textual                 │ String                 │
│ admitted │ Union{Missing, Textual} │ Union{Missing, String} │
└──────────┴─────────────────────────┴────────────────────────┘
</pre><ul><li>The model requires a table whose column element scitypes subtype <code>Continuous</code>, an incompatibility.</li></ul><h3 id="Common-data-preprocessing-workflows"><a class="docs-heading-anchor" href="#Common-data-preprocessing-workflows">Common data preprocessing workflows</a><a id="Common-data-preprocessing-workflows-1"></a><a class="docs-heading-anchor-permalink" href="#Common-data-preprocessing-workflows" title="Permalink"></a></h3><p>There are two tools for addressing data-model type mismatches like the above, with links to further documentation given below:</p><p><strong>Scientific type coercion:</strong> We coerce machine types to obtain the intended scientific interpretation. If <code>height</code> in the above example is intended to be <code>Continuous</code>, <code>mark</code> is supposed to be <code>OrderedFactor</code>, and <code>admitted</code> a (binary) <code>Multiclass</code>, then we can do</p><pre><code class="language-julia">X_coerced = coerce(X, :height=&gt;Continuous, :mark=&gt;OrderedFactor, :admitted=&gt;Multiclass);
schema(X_coerced)</code></pre><pre class="documenter-example-output">┌──────────┬───────────────────────────────┬────────────────────────────────────
│ names    │ scitypes                      │ types                             ⋯
├──────────┼───────────────────────────────┼────────────────────────────────────
│ height   │ Continuous                    │ Float64                           ⋯
│ time     │ Continuous                    │ Float64                           ⋯
│ mark     │ OrderedFactor{4}              │ CategoricalValue{String, UInt32}  ⋯
│ admitted │ Union{Missing, Multiclass{2}} │ Union{Missing, CategoricalValue{S ⋯
└──────────┴───────────────────────────────┴────────────────────────────────────
                                                                1 column omitted
</pre><p><strong>Data transformations:</strong> We carry out conventional data transformations, such as missing value imputation and feature encoding:</p><pre><code class="language-julia">imputer = FillImputer()
mach = machine(imputer, X_coerced) |&gt; fit!
X_imputed = transform(mach, X_coerced);
schema(X_imputed)</code></pre><pre class="documenter-example-output">┌──────────┬──────────────────┬──────────────────────────────────┐
│ names    │ scitypes         │ types                            │
├──────────┼──────────────────┼──────────────────────────────────┤
│ height   │ Continuous       │ Float64                          │
│ time     │ Continuous       │ Float64                          │
│ mark     │ OrderedFactor{4} │ CategoricalValue{String, UInt32} │
│ admitted │ Multiclass{2}    │ CategoricalValue{String, UInt32} │
└──────────┴──────────────────┴──────────────────────────────────┘
</pre><pre><code class="language-julia">encoder = ContinuousEncoder()
mach = machine(encoder, X_imputed) |&gt; fit!
X_encoded = transform(mach, X_imputed)</code></pre><pre class="documenter-example-output">(height = [185.0, 153.0, 163.0, 114.0, 180.0],
 time = [2.3, 4.5, 4.2, 1.8, 7.1],
 mark = [4.0, 1.0, 3.0, 2.0, 1.0],
 admitted__no = [0.0, 1.0, 0.0, 0.0],
 admitted__yes = [1.0, 0.0, 1.0, 1.0],)</pre><pre><code class="language-julia">schema(X_encoded)</code></pre><pre class="documenter-example-output">┌───────────────┬────────────┬─────────┐
│ names         │ scitypes   │ types   │
├───────────────┼────────────┼─────────┤
│ height        │ Continuous │ Float64 │
│ time          │ Continuous │ Float64 │
│ mark          │ Continuous │ Float64 │
│ admitted__no  │ Continuous │ Float64 │
│ admitted__yes │ Continuous │ Float64 │
└───────────────┴────────────┴─────────┘
</pre><p>Such transformations can also be combined in a pipeline; see <a href="../linear_pipelines/#Linear-Pipelines">Linear Pipelines</a>.</p><h2 id="Scientific-type-coercion"><a class="docs-heading-anchor" href="#Scientific-type-coercion">Scientific type coercion</a><a id="Scientific-type-coercion-1"></a><a class="docs-heading-anchor-permalink" href="#Scientific-type-coercion" title="Permalink"></a></h2><p>Scientific type coercion is documented in detail at <a href="https://github.com/JuliaAI/ScientificTypesBase.jl">ScientificTypesBase.jl</a>. See also the tutorial at the <a href="https://github.com/ablaom/MachineLearningInJulia2020">this MLJ Workshop</a> (specifically, <a href="https://github.com/ablaom/MachineLearningInJulia2020/blob/master/tutorials.md#fixing-scientific-types-in-tabular-data">here</a>) and <a href="https://alan-turing-institute.github.io/DataScienceTutorials.jl/data/scitype/">this Data Science in Julia tutorial</a>.</p><p>Also relevant is the section, <a href="../working_with_categorical_data/#Working-with-Categorical-Data">Working with Categorical Data</a>.</p><h2 id="Data-transformation"><a class="docs-heading-anchor" href="#Data-transformation">Data transformation</a><a id="Data-transformation-1"></a><a class="docs-heading-anchor-permalink" href="#Data-transformation" title="Permalink"></a></h2><p>MLJ&#39;s Built-in transformers are documented at <a href="../transformers/#Transformers-and-Other-Unsupervised-Models">Transformers and Other Unsupervised Models</a>. The most relevant in the present context   are: <a href="../transformers/#MLJModels.ContinuousEncoder"><code>ContinuousEncoder</code></a>, <a href="../transformers/#MLJModels.OneHotEncoder"><code>OneHotEncoder</code></a>,   <a href="../transformers/#MLJModels.FeatureSelector"><code>FeatureSelector</code></a> and <a href="../transformers/#MLJModels.FillImputer"><code>FillImputer</code></a>. A Gaussian   mixture models imputer is provided by BetaML, which can be loaded        with</p><pre><code class="language-julia">MissingImputator = @load MissingImputator pkg=BetaML</code></pre><p><a href="https://github.com/ablaom/MachineLearningInJulia2020">This MLJ Workshop</a>, and the &quot;End-to-end examples&quot; in <a href="https://alan-turing-institute.github.io/DataScienceTutorials.jl/">Data Science in Julia tutorials</a> give further illustrations of data preprocessing in MLJ.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../learning_curves/">« Learning Curves</a><a class="docs-footer-nextpage" href="../transformers/">Transformers and Other Unsupervised models »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 7 April 2022 01:19">Thursday 7 April 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
