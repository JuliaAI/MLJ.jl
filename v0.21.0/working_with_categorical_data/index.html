<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Working with Categorical Data · MLJ</title><meta name="title" content="Working with Categorical Data · MLJ"/><meta property="og:title" content="Working with Categorical Data · MLJ"/><meta property="twitter:title" content="Working with Categorical Data · MLJ"/><meta name="description" content="Documentation for MLJ."/><meta property="og:description" content="Documentation for MLJ."/><meta property="twitter:description" content="Documentation for MLJ."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="https://fonts.googleapis.com/css2?family=Lato:ital,wght@0,100;0,300;0,400;0,700;0,900;1,100;1,300;1,400;1,700;1,900&amp;family=Montserrat:ital,wght@0,100..900;1,100..900&amp;display=swap" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="MLJ logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">MLJ</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../model_browser/">Model Browser</a></li><li><a class="tocitem" href="../about_mlj/">About MLJ</a></li><li><a class="tocitem" href="../learning_mlj/">Learning MLJ</a></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Basics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../getting_started/">Getting Started</a></li><li><a class="tocitem" href="../common_mlj_workflows/">Common MLJ Workflows</a></li><li><a class="tocitem" href="../machines/">Machines</a></li><li><a class="tocitem" href="../mlj_cheatsheet/">MLJ Cheatsheet</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox" checked/><label class="tocitem" for="menuitem-6"><span class="docs-label">Data</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Working with Categorical Data</a><ul class="internal"><li><a class="tocitem" href="#Scientific-types-for-discrete-data"><span>Scientific types for discrete data</span></a></li><li><a class="tocitem" href="#Detecting-and-coercing-improperly-represented-categorical-data"><span>Detecting and coercing improperly represented categorical data</span></a></li><li><a class="tocitem" href="#Tracking-all-levels"><span>Tracking all levels</span></a></li><li><a class="tocitem" href="#New-or-missing-levels-in-production-data"><span>New or missing levels in production data</span></a></li><li><a class="tocitem" href="#Extracting-an-integer-representation-of-Finite-data"><span>Extracting an integer representation of Finite data</span></a></li><li><a class="tocitem" href="#Under-the-hood:-CategoricalValue-and-CategoricalArray"><span>Under the hood: CategoricalValue and CategoricalArray</span></a></li><li><a class="tocitem" href="#Probabilistic-predictions-of-categorical-data"><span>Probabilistic predictions of categorical data</span></a></li><li><a class="tocitem" href="#Reference"><span>Reference</span></a></li></ul></li><li><a class="tocitem" href="../preparing_data/">Preparing Data</a></li><li><a class="tocitem" href="../generating_synthetic_data/">Generating Synthetic Data</a></li><li><a class="tocitem" href="../openml_integration/">OpenML Integration</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Models</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../model_search/">Model Search</a></li><li><a class="tocitem" href="../loading_model_code/">Loading Model Code</a></li><li><a class="tocitem" href="../transformers/">Transformers and Other Unsupervised models</a></li><li><a class="tocitem" href="../feature_selection/">Feature Selection</a></li><li><a class="tocitem" href="../list_of_supported_models/">List of Supported Models</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">Meta-algorithms</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../evaluating_model_performance/">Evaluating Model Performance</a></li><li><a class="tocitem" href="../tuning_models/">Tuning Models</a></li><li><a class="tocitem" href="../learning_curves/">Learning Curves</a></li><li><a class="tocitem" href="../controlling_iterative_models/">Controlling Iterative Models</a></li><li><a class="tocitem" href="../correcting_class_imbalance/">Correcting Class Imbalance</a></li><li><a class="tocitem" href="../thresholding_probabilistic_predictors/">Thresholding Probabilistic Predictors</a></li><li><a class="tocitem" href="../target_transformations/">Target Transformations</a></li><li><a class="tocitem" href="../homogeneous_ensembles/">Homogeneous Ensembles</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox"/><label class="tocitem" for="menuitem-9"><span class="docs-label">Model Composition</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../composing_models/">Composing Models</a></li><li><a class="tocitem" href="../linear_pipelines/">Linear Pipelines</a></li><li><a class="tocitem" href="../model_stacking/">Model Stacking</a></li><li><a class="tocitem" href="../learning_networks/">Learning Networks</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-10" type="checkbox"/><label class="tocitem" for="menuitem-10"><span class="docs-label">Third Party Tools</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../logging_workflows/">Logging Workflows</a></li><li><a class="tocitem" href="../third_party_packages/">Third Party Packages</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11" type="checkbox"/><label class="tocitem" for="menuitem-11"><span class="docs-label">Customization and Extension</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../simple_user_defined_models/">Simple User Defined Models</a></li><li><a class="tocitem" href="../quick_start_guide_to_adding_models/">Quick-Start Guide to Adding Models</a></li><li><a class="tocitem" href="../adding_models_for_general_use/">Adding Models for General Use</a></li><li><a class="tocitem" href="../modifying_behavior/">Modifying Behavior</a></li><li><a class="tocitem" href="../internals/">Internals</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-12" type="checkbox"/><label class="tocitem" for="menuitem-12"><span class="docs-label">Miscellaneous</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../performance_measures/">Performance Measures</a></li><li><a class="tocitem" href="../weights/">Weights</a></li><li><a class="tocitem" href="../acceleration_and_parallelism/">Acceleration and Parallelism</a></li><li><a class="tocitem" href="../glossary/">Glossary</a></li><li><a class="tocitem" href="../frequently_asked_questions/">FAQ</a></li></ul></li><li><a class="tocitem" href="../api/">Index of Methods</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Data</a></li><li class="is-active"><a href>Working with Categorical Data</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Working with Categorical Data</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaAI/MLJ.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaAI/MLJ.jl/blob/dev/docs/src/working_with_categorical_data.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Working-with-Categorical-Data"><a class="docs-heading-anchor" href="#Working-with-Categorical-Data">Working with Categorical Data</a><a id="Working-with-Categorical-Data-1"></a><a class="docs-heading-anchor-permalink" href="#Working-with-Categorical-Data" title="Permalink"></a></h1><h2 id="Scientific-types-for-discrete-data"><a class="docs-heading-anchor" href="#Scientific-types-for-discrete-data">Scientific types for discrete data</a><a id="Scientific-types-for-discrete-data-1"></a><a class="docs-heading-anchor-permalink" href="#Scientific-types-for-discrete-data" title="Permalink"></a></h2><p>Recall that models articulate their data requirements using scientific types (see <a href="../getting_started/#Getting-Started">Getting Started</a> or the <a href="https://JuliaAI.github.io/ScientificTypes.jl/dev/">ScientificTypes.jl documentation</a>). There are three scientific types discrete data can have: <code>Count</code>, <code>OrderedFactor</code> and <code>Multiclass</code>.</p><h3 id="Count-data"><a class="docs-heading-anchor" href="#Count-data">Count data</a><a id="Count-data-1"></a><a class="docs-heading-anchor-permalink" href="#Count-data" title="Permalink"></a></h3><p>In MLJ you cannot use integers to represent (finite) categorical data. Integers are reserved for discrete data you want interpreted as <code>Count &lt;: Infinite</code>:</p><pre><code class="language-julia hljs">scitype([1, 4, 5, 6])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">AbstractVector{Count}<span class="sgr90"> (alias for AbstractArray{Count, 1})</span></code></pre><p>The <code>Count</code> scientific type includes things like the number of phone calls, or city populations, and other &quot;frequency&quot; data of a generally unbounded nature.</p><p>That said, you may have data that is theoretically <code>Count</code>, but which you coerce to <code>OrderedFactor</code> to enable the use of more models, trusting to your knowledge of how those models work to inform an appropriate interpretation.</p><h3 id="OrderedFactor-and-Multiclass-data"><a class="docs-heading-anchor" href="#OrderedFactor-and-Multiclass-data">OrderedFactor and Multiclass data</a><a id="OrderedFactor-and-Multiclass-data-1"></a><a class="docs-heading-anchor-permalink" href="#OrderedFactor-and-Multiclass-data" title="Permalink"></a></h3><p>Other integer data, such as the number of an animal&#39;s legs, or number of rooms in homes, are, generally, coerced to <code>OrderedFactor &lt;: Finite</code>. The other categorical scientific type is <code>Multiclass &lt;: Finite</code>, which is for <em>unordered</em> categorical data. Coercing data to one of these two forms is discussed under <a href="#Detecting-and-coercing-improperly-represented-categorical-data"> Detecting and coercing improperly represented categorical data</a> below.</p><h3 id="Binary-data"><a class="docs-heading-anchor" href="#Binary-data">Binary data</a><a id="Binary-data-1"></a><a class="docs-heading-anchor-permalink" href="#Binary-data" title="Permalink"></a></h3><p>There is no separate scientific type for binary data. Binary data is either <code>OrderedFactor{2}</code> if ordered, and <code>Multiclass{2}</code> otherwise. Data with type <code>OrderedFactor{2}</code> is considered to have an intrinsic &quot;positive&quot; class, e.g., the outcome of a medical test, and the &quot;pass/fail&quot; outcome of an exam. MLJ measures, such as <code>true_positive</code> assume the <em>second</em> class in the ordering is the &quot;positive&quot; class. Inspecting and changing order are discussed in the next section.</p><p>If data has type <code>Bool</code> it is considered <code>Count</code> data (as <code>Bool &lt;: Integer</code>) and, generally, users will want to coerce such data to <code>Multiclass</code> or <code>OrderedFactor</code>.</p><h2 id="Detecting-and-coercing-improperly-represented-categorical-data"><a class="docs-heading-anchor" href="#Detecting-and-coercing-improperly-represented-categorical-data">Detecting and coercing improperly represented categorical data</a><a id="Detecting-and-coercing-improperly-represented-categorical-data-1"></a><a class="docs-heading-anchor-permalink" href="#Detecting-and-coercing-improperly-represented-categorical-data" title="Permalink"></a></h2><p>One inspects the scientific type of data using <code>scitype</code> as shown above. To inspect all column scientific types in a table simultaneously, use <code>schema</code>. (The <code>scitype(X)</code> of a table <code>X</code> contains a condensed form of this information used in type dispatch; see <a href="https://github.com/JuliaAI/ScientificTypesBase.jl#more-on-the-table-type">here</a>.)</p><pre><code class="language-julia hljs">import DataFrames: DataFrame
X = DataFrame(
    name = [&quot;Siri&quot;, &quot;Robo&quot;, &quot;Alexa&quot;, &quot;Cortana&quot;],
    gender = [&quot;male&quot;, &quot;male&quot;, &quot;Female&quot;, &quot;female&quot;],
    likes_soup = [true, false, false, true],
    height = [152, missing, 148, 163],
    rating = [2, 5, 2, 1],
    outcome = [&quot;rejected&quot;, &quot;accepted&quot;, &quot;accepted&quot;, &quot;rejected&quot;],
)
schema(X)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌────────────┬───────────────────────┬───────────────────────┐
│ names      │ scitypes              │ types                 │
├────────────┼───────────────────────┼───────────────────────┤
│ name       │ Textual               │ String                │
│ gender     │ Textual               │ String                │
│ likes_soup │ Count                 │ Bool                  │
│ height     │ Union{Missing, Count} │ Union{Missing, Int64} │
│ rating     │ Count                 │ Int64                 │
│ outcome    │ Textual               │ String                │
└────────────┴───────────────────────┴───────────────────────┘
</code></pre><p>Coercing a single column:</p><pre><code class="language-julia hljs">X.outcome = coerce(X.outcome, OrderedFactor)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element CategoricalArray{String,1,UInt32}:
 &quot;rejected&quot;
 &quot;accepted&quot;
 &quot;accepted&quot;
 &quot;rejected&quot;</code></pre><p>The <em>machine</em> type of the result is a <code>CategoricalArray</code>. For more on this type see <a href="#Under-the-hood:-CategoricalValue-and-CategoricalArray">Under the hood: CategoricalValue and CategoricalArray</a> below.</p><p>Inspecting the order of the levels:</p><pre><code class="language-julia hljs">levels(X.outcome)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{String}:
 &quot;accepted&quot;
 &quot;rejected&quot;</code></pre><p>Since we wish to regard &quot;accepted&quot; as the positive class, it should appear second, which we correct with the <code>levels!</code> function:</p><pre><code class="language-julia hljs">levels!(X.outcome, [&quot;rejected&quot;, &quot;accepted&quot;])
levels(X.outcome)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{String}:
 &quot;rejected&quot;
 &quot;accepted&quot;</code></pre><div class="admonition is-warning" id="Changing-levels-of-categorical-data-2b4ece60a6feeb04"><header class="admonition-header">Changing levels of categorical data<a class="admonition-anchor" href="#Changing-levels-of-categorical-data-2b4ece60a6feeb04" title="Permalink"></a></header><div class="admonition-body"><p>The order of levels should generally be changed early in your data science workflow and then not again. Similar remarks apply to <em>adding</em> levels (which is possible; see the <a href="https://juliadata.github.io/CategoricalArrays.jl/stable/">CategorialArrays.jl documentation</a>). MLJ supervised and unsupervised models assume levels and their order do not change.</p></div></div><p>Coercing all remaining types simultaneously:</p><pre><code class="language-julia hljs">Xnew = coerce(X, :gender     =&gt; Multiclass,
                 :likes_soup =&gt; OrderedFactor,
                 :height     =&gt; Continuous,
                 :rating     =&gt; OrderedFactor)
schema(Xnew)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌────────────┬────────────────────────────┬──────────────────────────────────┐
│ names      │ scitypes                   │ types                            │
├────────────┼────────────────────────────┼──────────────────────────────────┤
│ name       │ Textual                    │ String                           │
│ gender     │ Multiclass{3}              │ CategoricalValue{String, UInt32} │
│ likes_soup │ OrderedFactor{2}           │ CategoricalValue{Bool, UInt32}   │
│ height     │ Union{Missing, Continuous} │ Union{Missing, Float64}          │
│ rating     │ OrderedFactor{3}           │ CategoricalValue{Int64, UInt32}  │
│ outcome    │ OrderedFactor{2}           │ CategoricalValue{String, UInt32} │
└────────────┴────────────────────────────┴──────────────────────────────────┘
</code></pre><p>For <code>DataFrame</code>s there is also in-place coercion, using <code>coerce!</code>.</p><h2 id="Tracking-all-levels"><a class="docs-heading-anchor" href="#Tracking-all-levels">Tracking all levels</a><a id="Tracking-all-levels-1"></a><a class="docs-heading-anchor-permalink" href="#Tracking-all-levels" title="Permalink"></a></h2><p>The key property of vectors of scientific type <code>OrderedFactor</code> and  <code>Multiclass</code> is that the pool of all levels is not lost when separating out one or more elements:</p><pre><code class="language-julia hljs">v = Xnew.rating</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element CategoricalArray{Int64,1,UInt32}:
 2
 5
 2
 1</code></pre><pre><code class="language-julia hljs">levels(v)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Int64}:
 1
 2
 5</code></pre><pre><code class="language-julia hljs">levels(v[1:2])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Int64}:
 1
 2
 5</code></pre><pre><code class="language-julia hljs">levels(v[2])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Int64}:
 1
 2
 5</code></pre><p>By tracking all classes in this way, MLJ avoids common pain points around categorical data, such as evaluating models on an evaluation set, only to crash your code because classes appear there which were not seen during training.</p><p>By drawing test, validation and training data from a common data structure (as described in <a href="../getting_started/#Getting-Started">Getting Started</a>, for example) one ensures that all possible classes of categorical variables are tracked at all times. However, this does not mitigate problems with new <em>production</em> data, if categorical features there are missing classes or contain previously unseen classes.</p><h2 id="New-or-missing-levels-in-production-data"><a class="docs-heading-anchor" href="#New-or-missing-levels-in-production-data">New or missing levels in production data</a><a id="New-or-missing-levels-in-production-data-1"></a><a class="docs-heading-anchor-permalink" href="#New-or-missing-levels-in-production-data" title="Permalink"></a></h2><div class="admonition is-warning" id="Warning-6a8094c9973a7353"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-6a8094c9973a7353" title="Permalink"></a></header><div class="admonition-body"><p>Unpredictable behavior may result whenever <code>Finite</code> categorical data presents in a production set with different classes (levels) from those presented during training</p></div></div><p>Consider, for example, the following naive workflow:</p><pre><code class="language-julia hljs"># train a one-hot encoder on some data:
x = coerce([&quot;black&quot;, &quot;white&quot;, &quot;white&quot;, &quot;black&quot;], Multiclass)
X = DataFrame(x=x)

model = OneHotEncoder()
mach = machine(model, X) |&gt; fit!

# one-hot encode new data with missing classes:
xproduction = coerce([&quot;white&quot;, &quot;white&quot;], Multiclass)
Xproduction = DataFrame(x=xproduction)
Xproduction == X[2:3,:]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>So far, so good. But the following operation throws an error:</p><pre><code class="language-julia-repl hljs">julia&gt; transform(mach, Xproduction) == transform(mach, X[2:3,:])
ERROR: Found category level mismatch in feature `x`. Consider using `levels!` to ensure fitted and transforming features have the same category levels.</code></pre><p>The problem here is that <code>levels(X.x)</code> and <code>levels(Xproduction.x)</code> are different:</p><pre><code class="language-julia hljs">levels(X.x)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{String}:
 &quot;black&quot;
 &quot;white&quot;</code></pre><pre><code class="language-julia hljs">levels(Xproduction.x)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1-element Vector{String}:
 &quot;white&quot;</code></pre><p>This could be anticipated by the fact that the training and production data have different schema:</p><pre><code class="language-julia hljs">schema(X)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌───────┬───────────────┬──────────────────────────────────┐
│ names │ scitypes      │ types                            │
├───────┼───────────────┼──────────────────────────────────┤
│ x     │ Multiclass{2} │ CategoricalValue{String, UInt32} │
└───────┴───────────────┴──────────────────────────────────┘
</code></pre><pre><code class="language-julia hljs">schema(Xproduction)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌───────┬───────────────┬──────────────────────────────────┐
│ names │ scitypes      │ types                            │
├───────┼───────────────┼──────────────────────────────────┤
│ x     │ Multiclass{1} │ CategoricalValue{String, UInt32} │
└───────┴───────────────┴──────────────────────────────────┘
</code></pre><p>One fix is to manually correct the levels of the production data:</p><pre><code class="language-julia hljs">levels!(Xproduction.x, levels(x))
transform(mach, Xproduction) == transform(mach, X[2:3,:])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>Another solution is to pack all production data with dummy rows based on the training data (subsequently dropped) to ensure there are no missing classes. Currently, MLJ contains no general tooling to check and fix categorical levels in production data (although one can check that training data and production data have the same schema, to ensure the <em>number</em> of classes in categorical data is consistent).</p><h2 id="Extracting-an-integer-representation-of-Finite-data"><a class="docs-heading-anchor" href="#Extracting-an-integer-representation-of-Finite-data">Extracting an integer representation of Finite data</a><a id="Extracting-an-integer-representation-of-Finite-data-1"></a><a class="docs-heading-anchor-permalink" href="#Extracting-an-integer-representation-of-Finite-data" title="Permalink"></a></h2><p>Occasionally, you may really want an integer representation of data that currently has scitype <code>Finite</code>. For example, you are a developer wrapping an algorithm from an external package for use in MLJ, and that algorithm uses integer representations. Use the <code>int</code> method for this purpose, and use <code>decoder</code> to construct decoders for reversing the transformation:</p><pre><code class="language-julia hljs">v = coerce([&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;one&quot;], OrderedFactor);
levels!(v, [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]);
v_int = int(v)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{UInt32}:
 0x00000001
 0x00000002
 0x00000003
 0x00000001</code></pre><pre><code class="language-julia hljs">d = decoder(v); # or decoder(v[1])
d.(v_int)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element CategoricalArray{String,1,UInt32}:
 &quot;one&quot;
 &quot;two&quot;
 &quot;three&quot;
 &quot;one&quot;</code></pre><h2 id="Under-the-hood:-CategoricalValue-and-CategoricalArray"><a class="docs-heading-anchor" href="#Under-the-hood:-CategoricalValue-and-CategoricalArray">Under the hood: CategoricalValue and CategoricalArray</a><a id="Under-the-hood:-CategoricalValue-and-CategoricalArray-1"></a><a class="docs-heading-anchor-permalink" href="#Under-the-hood:-CategoricalValue-and-CategoricalArray" title="Permalink"></a></h2><p>In MLJ the objects with <code>OrderedFactor</code> or <code>Multiclass</code> scientific type have machine type <code>CategoricalValue</code>, from the <a href="https://juliadata.github.io/CategoricalArrays.jl/stable/">CategoricalArrays.jl</a> package. In some sense <code>CategoricalValue</code>s are an implementation detail users can ignore for the most part, as shown above. However, you may want some basic understanding of these types, and those implementing MLJ&#39;s model interface for new algorithms will have to understand them. For the complete API, see the CategoricalArrays.jl <a href="https://juliadata.github.io/CategoricalArrays.jl/stable/">documentation</a>. Here are the basics:</p><p>To construct an <code>OrderedFactor</code> or <code>Multiclass</code> vector directly from raw labels, one uses <code>categorical</code>:</p><pre><code class="language-julia hljs">v = categorical([&#39;A&#39;, &#39;B&#39;, &#39;A&#39;, &#39;A&#39;, &#39;C&#39;])
typeof(v)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">CategoricalVector{Char, UInt32, Char, CategoricalValue{Char, UInt32}, Union{}}<span class="sgr90"> (alias for CategoricalArray{Char, 1, UInt32, Char, CategoricalValue{Char, UInt32}, Union{}})</span></code></pre><p>(Equivalent to the idiomatically MLJ <code>v = coerce([&#39;A&#39;, &#39;B&#39;, &#39;A&#39;, &#39;A&#39;, &#39;C&#39;]), Multiclass)</code>.)</p><pre><code class="language-julia hljs">scitype(v)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">AbstractVector{Multiclass{3}}<span class="sgr90"> (alias for AbstractArray{Multiclass{3}, 1})</span></code></pre><pre><code class="language-julia hljs">v = categorical([&#39;A&#39;, &#39;B&#39;, &#39;A&#39;, &#39;A&#39;, &#39;C&#39;], ordered=true, compress=true)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5-element CategoricalArray{Char,1,UInt8}:
 &#39;A&#39;
 &#39;B&#39;
 &#39;A&#39;
 &#39;A&#39;
 &#39;C&#39;</code></pre><pre><code class="language-julia hljs">scitype(v)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">AbstractVector{OrderedFactor{3}}<span class="sgr90"> (alias for AbstractArray{OrderedFactor{3}, 1})</span></code></pre><p>When you index a <code>CategoricalVector</code> you don&#39;t get a raw label, but instead an instance of <code>CategoricalValue</code>. As explained above, this value knows the complete pool of levels from the vector from which it came. Use <code>get(val)</code> to extract the raw label from a value <code>val</code>.</p><p>Despite the distinction that exists between a value (element) and a label, the two are the same, from the point of <code>==</code> and <code>in</code>:</p><pre><code class="language-julia hljs">v[1] == &#39;A&#39; # true
&#39;A&#39; in v    # true</code></pre><h2 id="Probabilistic-predictions-of-categorical-data"><a class="docs-heading-anchor" href="#Probabilistic-predictions-of-categorical-data">Probabilistic predictions of categorical data</a><a id="Probabilistic-predictions-of-categorical-data-1"></a><a class="docs-heading-anchor-permalink" href="#Probabilistic-predictions-of-categorical-data" title="Permalink"></a></h2><p>Recall from <a href="../getting_started/#Getting-Started">Getting Started</a> that probabilistic classifiers ordinarily predict <code>UnivariateFinite</code> distributions, not raw probabilities (which are instead accessed using the <code>pdf</code> method.) Here&#39;s how to construct such a distribution yourself:</p><pre><code class="language-julia hljs">v = coerce([&quot;yes&quot;, &quot;no&quot;, &quot;yes&quot;, &quot;yes&quot;, &quot;maybe&quot;], Multiclass)
d = UnivariateFinite([v[2], v[1]], [0.9, 0.1])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">UnivariateFinite{Multiclass{3}}(no=&gt;0.9, yes=&gt;0.1)</code></pre><p>Or, equivalently,</p><pre><code class="language-julia hljs">d = UnivariateFinite([&quot;no&quot;, &quot;yes&quot;], [0.9, 0.1], pool=v)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">UnivariateFinite{Multiclass{3}}(no=&gt;0.9, yes=&gt;0.1)</code></pre><p>This distribution tracks <em>all</em> levels, not just the ones to which you have assigned probabilities:</p><pre><code class="language-julia hljs">pdf(d, &quot;maybe&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.0</code></pre><p>However, <code>pdf(d, &quot;dunno&quot;)</code> will throw an error.</p><p>You can declare <code>pool=missing</code>, but then <code>&quot;maybe&quot;</code> will not be tracked:</p><pre><code class="language-julia hljs">d = UnivariateFinite([&quot;no&quot;, &quot;yes&quot;], [0.9, 0.1], pool=missing)
levels(d)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{String}:
 &quot;no&quot;
 &quot;yes&quot;</code></pre><p>To construct a whole <em>vector</em> of <code>UnivariateFinite</code> distributions, simply give the constructor a matrix of probabilities:</p><pre><code class="language-julia hljs">yes_probs = rand(5)
probs = hcat(1 .- yes_probs, yes_probs)
d_vec = UnivariateFinite([&quot;no&quot;, &quot;yes&quot;], probs, pool=v)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5-element UnivariateFiniteVector{Multiclass{3}, String, UInt32, Float64}:
 UnivariateFinite{Multiclass{3}}(no=&gt;0.492, yes=&gt;0.508)
 UnivariateFinite{Multiclass{3}}(no=&gt;0.801, yes=&gt;0.199)
 UnivariateFinite{Multiclass{3}}(no=&gt;0.24, yes=&gt;0.76)
 UnivariateFinite{Multiclass{3}}(no=&gt;0.429, yes=&gt;0.571)
 UnivariateFinite{Multiclass{3}}(no=&gt;0.77, yes=&gt;0.23)</code></pre><p>Or, equivalently:</p><pre><code class="language-julia hljs">d_vec = UnivariateFinite([&quot;no&quot;, &quot;yes&quot;], yes_probs, augment=true, pool=v)</code></pre><p>For more options, see <a href="#CategoricalDistributions.UnivariateFinite"><code>UnivariateFinite</code></a>.</p><h2 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CategoricalDistributions.UnivariateFinite" href="#CategoricalDistributions.UnivariateFinite"><code>CategoricalDistributions.UnivariateFinite</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UnivariateFinite(support,
                 probs;
                 pool=nothing,
                 augmented=false,
                 ordered=false)</code></pre><p>Construct a discrete univariate distribution whose finite support is the elements of the vector <code>support</code>, and whose corresponding probabilities are elements of the vector <code>probs</code>. Alternatively, construct an abstract <em>array</em> of <code>UnivariateFinite</code> distributions by choosing <code>probs</code> to be an array of one higher dimension than the array generated.</p><p>Here the word &quot;probabilities&quot; is an abuse of terminology as there is no requirement that the that probabilities actually sum to one. The only requirement is that the probabilities have a common type <code>T</code> for which <code>zero(T)</code> is defined. In particular, <code>UnivariateFinite</code> objects implement arbitrary non-negative, signed, or complex measures over finite sets of labelled points. A <code>UnivariateDistribution</code> will be a bona fide probability measure when constructed using the <code>augment=true</code> option (see below) or when <code>fit</code> to data. And the probabilities of a <code>UnivariateFinite</code> object <code>d</code> must be non-negative, with a non-zero sum, for <code>rand(d)</code> to be defined and interpretable.</p><p>Unless <code>pool</code> is specified, <code>support</code> should have type  <code>AbstractVector{&lt;:CategoricalValue}</code> and all elements are assumed to  share the same categorical pool, which may be larger than <code>support</code>.</p><p><em>Important.</em> All levels of the common pool have associated probabilities, not just those in the specified <code>support</code>. However, these probabilities are always zero (see example below).</p><p>If <code>probs</code> is a matrix, it should have a column for each class in <code>support</code> (or one less, if <code>augment=true</code>). More generally, <code>probs</code> will be an array whose size is of the form <code>(n1, n2, ..., nk, c)</code>, where <code>c = length(support)</code> (or one less, if <code>augment=true</code>) and the constructor then returns an array of <code>UnivariateFinite</code> distributions of size <code>(n1, n2, ..., nk)</code>.</p><pre><code class="nohighlight hljs">using CategoricalDistributions, CategoricalArrays, Distributions
samples = categorical([&#39;x&#39;, &#39;x&#39;, &#39;y&#39;, &#39;x&#39;, &#39;z&#39;])
julia&gt; Distributions.fit(UnivariateFinite, samples)
           UnivariateFinite{Multiclass{3}}
     ┌                                        ┐
   x ┤■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■ 0.6
   y ┤■■■■■■■■■■■■ 0.2
   z ┤■■■■■■■■■■■■ 0.2
     └                                        ┘

julia&gt; d = UnivariateFinite([samples[1], samples[end]], [0.1, 0.9])
UnivariateFinite{Multiclass{3}(x=&gt;0.1, z=&gt;0.9)
           UnivariateFinite{Multiclass{3}}
     ┌                                        ┐
   x ┤■■■■ 0.1
   z ┤■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■ 0.9
     └                                        ┘

julia&gt; rand(d, 3)
3-element Array{Any,1}:
 CategoricalValue{Symbol,UInt32} &#39;z&#39;
 CategoricalValue{Symbol,UInt32} &#39;z&#39;
 CategoricalValue{Symbol,UInt32} &#39;z&#39;

julia&gt; levels(samples)
3-element Array{Symbol,1}:
 &#39;x&#39;
 &#39;y&#39;
 &#39;z&#39;

julia&gt; pdf(d, &#39;y&#39;)
0.0</code></pre><p><strong>Specifying a pool</strong></p><p>Alternatively, <code>support</code> may be a list of raw (non-categorical) elements if <code>pool</code> is:</p><ul><li><p>some <code>CategoricalArray</code>, <code>CategoricalValue</code> or <code>CategoricalPool</code>, such that <code>support</code> is a subset of <code>levels(pool)</code></p></li><li><p><code>missing</code>, in which case a new categorical pool is created which has <code>support</code> as its only levels.</p></li></ul><p>In the last case, specify <code>ordered=true</code> if the pool is to be considered ordered.</p><pre><code class="nohighlight hljs">julia&gt; UnivariateFinite([&#39;x&#39;, &#39;z&#39;], [0.1, 0.9], pool=missing, ordered=true)
         UnivariateFinite{OrderedFactor{2}}
     ┌                                        ┐
   x ┤■■■■ 0.1
   z ┤■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■ 0.9
     └                                        ┘

samples = categorical([&#39;x&#39;, &#39;x&#39;, &#39;y&#39;, &#39;x&#39;, &#39;z&#39;])
julia&gt; d = UnivariateFinite([&#39;x&#39;, &#39;z&#39;], [0.1, 0.9], pool=samples)
     ┌                                        ┐
   x ┤■■■■ 0.1
   z ┤■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■ 0.9
     └                                        ┘

julia&gt; pdf(d, &#39;y&#39;) # allowed as `&#39;y&#39; in levels(samples)`
0.0

v = categorical([&#39;x&#39;, &#39;x&#39;, &#39;y&#39;, &#39;x&#39;, &#39;z&#39;, &#39;w&#39;])
probs = rand(100, 3)
probs = probs ./ sum(probs, dims=2)
julia&gt; d1 = UnivariateFinite([&#39;x&#39;, &#39;y&#39;, &#39;z&#39;], probs, pool=v)
100-element UnivariateFiniteVector{Multiclass{4},Symbol,UInt32,Float64}:
 UnivariateFinite{Multiclass{4}}(x=&gt;0.194, y=&gt;0.3, z=&gt;0.505)
 UnivariateFinite{Multiclass{4}}(x=&gt;0.727, y=&gt;0.234, z=&gt;0.0391)
 UnivariateFinite{Multiclass{4}}(x=&gt;0.674, y=&gt;0.00535, z=&gt;0.321)
   ⋮
 UnivariateFinite{Multiclass{4}}(x=&gt;0.292, y=&gt;0.339, z=&gt;0.369)</code></pre><p><strong>Probability augmentation</strong></p><p>If <code>augment=true</code> the provided array is augmented by inserting appropriate elements <em>ahead</em> of those provided, along the last dimension of the array. This means the user only provides probabilities for the classes <code>c2, c3, ..., cn</code>. The class <code>c1</code> probabilities are chosen so that each <code>UnivariateFinite</code> distribution in the returned array is a bona fide probability distribution.</p><pre><code class="language-julia hljs">julia&gt; UnivariateFinite([0.1, 0.2, 0.3], augment=true, pool=missing)
3-element UnivariateFiniteArray{Multiclass{2}, String, UInt8, Float64, 1}:
 UnivariateFinite{Multiclass{2}}(class_1=&gt;0.9, class_2=&gt;0.1)
 UnivariateFinite{Multiclass{2}}(class_1=&gt;0.8, class_2=&gt;0.2)
 UnivariateFinite{Multiclass{2}}(class_1=&gt;0.7, class_2=&gt;0.3)

d2 = UnivariateFinite([&#39;x&#39;, &#39;y&#39;, &#39;z&#39;], probs[:, 2:end], augment=true, pool=v)
julia&gt; pdf(d1, levels(v)) ≈ pdf(d2, levels(v))
true</code></pre><hr/><pre><code class="nohighlight hljs">UnivariateFinite(prob_given_class; pool=nothing, ordered=false)</code></pre><p>Construct a discrete univariate distribution whose finite support is the set of keys of the provided dictionary, <code>prob_given_class</code>, and whose values specify the corresponding probabilities.</p><p>The type requirements on the keys of the dictionary are the same as the elements of <code>support</code> given above with this exception: if non-categorical elements (raw labels) are used as keys, then <code>pool=...</code> must be specified and cannot be <code>missing</code>.</p><p>If the values (probabilities) are arrays instead of scalars, then an abstract array of <code>UnivariateFinite</code> elements is created, with the same size as the array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/CategoricalDistributions.jl/blob/v0.1.15/src/types.jl#L177-L334">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../mlj_cheatsheet/">« MLJ Cheatsheet</a><a class="docs-footer-nextpage" href="../preparing_data/">Preparing Data »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Wednesday 10 September 2025 07:45">Wednesday 10 September 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
