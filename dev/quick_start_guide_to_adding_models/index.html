<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Quick-Start Guide to Adding Models · MLJ</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="MLJ logo"/></a><div class="docs-package-name"><span class="docs-autofit">MLJ</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../getting_started/">Getting Started</a></li><li><a class="tocitem" href="../common_mlj_workflows/">Common MLJ Workflows</a></li><li><a class="tocitem" href="../working_with_categorical_data/">Working with Categorical Data</a></li><li><a class="tocitem" href="../model_search/">Model Search</a></li><li><a class="tocitem" href="../loading_model_code/">Loading Model Code</a></li><li><a class="tocitem" href="../machines/">Machines</a></li><li><a class="tocitem" href="../evaluating_model_performance/">Evaluating Model Performance</a></li><li><a class="tocitem" href="../performance_measures/">Performance Measures</a></li><li><a class="tocitem" href="../tuning_models/">Tuning Models</a></li><li><a class="tocitem" href="../learning_curves/">Learning Curves</a></li><li><a class="tocitem" href="../transformers/">Transformers and other unsupervised models</a></li><li><a class="tocitem" href="../controlling_iterative_models/">Controlling Iterative Models</a></li><li><a class="tocitem" href="../composing_models/">Composing Models</a></li><li><a class="tocitem" href="../homogeneous_ensembles/">Homogeneous Ensembles</a></li><li><a class="tocitem" href="../generating_synthetic_data/">Generating Synthetic Data</a></li><li><a class="tocitem" href="../openml_integration/">OpenML Integration</a></li><li><a class="tocitem" href="../acceleration_and_parallelism/">Acceleration and Parallelism</a></li><li><a class="tocitem" href="../simple_user_defined_models/">Simple User Defined Models</a></li><li class="is-active"><a class="tocitem" href>Quick-Start Guide to Adding Models</a></li><li><a class="tocitem" href="../adding_models_for_general_use/">Adding Models for General Use</a></li><li><a class="tocitem" href="../benchmarking/">Benchmarking</a></li><li><a class="tocitem" href="../internals/">Internals</a></li><li><a class="tocitem" href="../list_of_supported_models/">List of Supported Models</a></li><li><a class="tocitem" href="../third_party_packages/">Third Party Packages</a></li><li><a class="tocitem" href="../glossary/">Glossary</a></li><li><a class="tocitem" href="../mlj_cheatsheet/">MLJ Cheatsheet</a></li><li><a class="tocitem" href="../frequently_asked_questions/">FAQ</a></li><li><a class="tocitem" href="../julia_blogpost/">Julia BlogPost</a></li><li><a class="tocitem" href="../api/">Index of Methods</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Quick-Start Guide to Adding Models</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Quick-Start Guide to Adding Models</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/alan-turing-institute/MLJ.jl/blob/master/docs/src/quick_start_guide_to_adding_models.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Quick-Start-Guide-to-Adding-Models-1"><a class="docs-heading-anchor" href="#Quick-Start-Guide-to-Adding-Models-1">Quick-Start Guide to Adding Models</a><a class="docs-heading-anchor-permalink" href="#Quick-Start-Guide-to-Adding-Models-1" title="Permalink"></a></h1><p>The definitive specification of the MLJ model interface is given in <a href="../adding_models_for_general_use/#Adding-Models-for-General-Use-1">Adding Models for General Use</a>. In the more informal and condensed instructions below, we assume: (i) you have a Julia <strong>registered</strong> package <code>YourPackage.jl</code> implementing some machine learning models; (ii) that you would like to interface and register these models with MLJ; and (iii) that you have a rough understanding of how things work with MLJ.  In particular you are familiar with:</p><ul><li><p>what <a href="https://github.com/alan-turing-institute/MLJScientificTypes.jl">scientific types</a> are</p></li><li><p>what <code>Probabilistic</code>, <code>Deterministic</code> and <code>Unsupervised</code> models are</p></li><li><p>the fact that MLJ generally works with tables rather than bare bone matrices. Here a <em>table</em> is a container satisfying the <a href="https://github.com/JuliaData/Tables.jl">Tables.jl</a> API (e.g., DataFrame, JuliaDB table, CSV file, named tuple of equi-length vectors)</p></li><li><p><a href="https://github.com/JuliaData/CategoricalArrays.jl">CategoricalArrays.jl</a> (if working with finite discrete data, e.g., doing classification)</p></li></ul><p>If you&#39;re not familiar with any one of these points, please refer to relevant sections of this manual, and in particular <a href="../getting_started/#Getting-Started-1">Getting Started</a> and <a href="../adding_models_for_general_use/#Adding-Models-for-General-Use-1">Adding Models for General Use</a>.</p><p><em>But tables don&#39;t make sense for my model!</em> If a case can be made that tabular input does not make sense for your particular model, then MLJ can still handle this; you just need to define a non-tabular <code>input_scitype</code> trait. However, you should probably open an issue to clarify the appropriate declaration. The discussion below assumes input data is tabular.</p><p>For simplicity, this document assumes no data front-end is to be defined for your model. Adding a data front-end, which offers the MLJ user some performances benefits, is easy to add post-facto, and is described in <a href="../adding_models_for_general_use/#Implementing-a-data-front-end-1">Implementing a data front-end</a>.</p><h3 id="Overview-1"><a class="docs-heading-anchor" href="#Overview-1">Overview</a><a class="docs-heading-anchor-permalink" href="#Overview-1" title="Permalink"></a></h3><p>To write an interface create a file or a module in your package which includes:</p><ul><li><p>a <code>using MLJModelInterface</code> or <code>import MLJModelInterface</code> statement</p></li><li><p>MLJ-compatible model types and constructors,</p></li><li><p>implementation of <code>fit</code>, <code>predict</code>/<code>transform</code> and optionally <code>fitted_params</code> for your models,</p></li><li><p>metadata for your package and for each of your models</p></li></ul><h4 id="Important-1"><a class="docs-heading-anchor" href="#Important-1">Important</a><a class="docs-heading-anchor-permalink" href="#Important-1" title="Permalink"></a></h4><p><a href="https://github.com/alan-turing-institute/MLJModelInterface.jl">MLJModelInterface</a> is a very light-weight interface allowing you to <em>define</em> your interface, but does not provide the functionality required to use or test your interface; this requires <a href="https://github.com/alan-turing-institute/MLJBase.jl">MLJBase</a>. So, while you only need to add <code>MLJModelInterface</code> to your project&#39;s [deps], for testing purposes you need to add <a href="https://github.com/alan-turing-institute/MLJBase.jl">MLJBase</a> to your project&#39;s [extras] and [targets]. In testing, simply use <code>MLJBase</code> in place of <code>MLJModelInterface</code>.</p><p>We give some details for each step below with, each time, a few examples that you can mimic.  The instructions are intentionally brief.</p><h3 id="Model-type-and-constructor-1"><a class="docs-heading-anchor" href="#Model-type-and-constructor-1">Model type and constructor</a><a class="docs-heading-anchor-permalink" href="#Model-type-and-constructor-1" title="Permalink"></a></h3><p>MLJ-compatible constructors for your models need to meet the following requirements:</p><ul><li>be <code>mutable struct</code>,</li><li>be subtypes of <code>MLJModelInterface.Probabilistic</code> or <code>MLJModelInterface.Deterministic</code> or <code>MLJModelInterface.Unsupervised</code>,</li><li>have fields corresponding exclusively to hyperparameters,</li><li>have a keyword constructor assigning default values to all hyperparameters.</li></ul><p>You may use the <code>@mlj_model</code> macro from <code>MLJModelInterface</code> to declare a (non parametric) model type:</p><pre><code class="language-julia">MLJModelInterface.@mlj_model mutable struct YourModel &lt;: MLJModelInterface.Deterministic
    a::Float64 = 0.5::(_ &gt; 0)
    b::String  = &quot;svd&quot;::(_ in (&quot;svd&quot;,&quot;qr&quot;))
end</code></pre><p>That macro specifies:</p><ul><li>A keyword constructor (here <code>YourModel(; a=..., b=...)</code>),</li><li>Default values for the hyperparameters,</li><li>Constraints on the hyperparameters where <code>_</code> refers to a value passed.</li></ul><p>Further to the last point, <code>a::Float64 = 0.5::(_ &gt; 0)</code> indicates that the field <code>a</code> is a <code>Float64</code>, takes <code>0.5</code> as default value, and expects its value to be positive.</p><p>Please see <a href="https://github.com/alan-turing-institute/MLJBase.jl/issues/68">this issue</a> for a known issue and workaround relating to the use of <code>@mlj_model</code> with negative defaults.</p><p>If you decide <strong>not</strong> to use the <code>@mlj_model</code> macro (e.g. in the case of a parametric type), you will need to write a keyword constructor and a <code>clean!</code> method:</p><pre><code class="language-julia">mutable struct YourModel &lt;: MLJModelInterface.Deterministic
    a::Float64
end
function YourModel(; a=0.5)
    model   = YourModel(a)
    message = MLJModelInterface.clean!(model)
    isempty(message) || @warn message
    return model
end
function MLJModelInterface.clean!(m::YourModel)
    warning = &quot;&quot;
    if m.a &lt;= 0
        warning *= &quot;Parameter `a` expected to be positive, resetting to 0.5&quot;
        m.a = 0.5
    end
    return warning
end</code></pre><p><strong>Additional notes</strong>:</p><ul><li><p>Please annotate all fields with concrete types, if possible, using type parameters if necessary.</p></li><li><p>Please prefer <code>Symbol</code> over <code>String</code> if you can (e.g. to pass the name of a solver).</p></li><li><p>Please add constraints to your fields even if they seem obvious to you.</p></li><li><p>Your model may have 0 fields, that&#39;s fine.</p></li><li><p>Although not essential, try to avoid Union types for model fields. For example, a field declaration <code>features::Vector{Symbol}</code> with a default of <code>Symbol[]</code> (detected with the <code>isempty</code> method) is preferred to <code>features::Union{Vector{Symbol}, Nothing}</code> with a default of <code>nothing</code>.</p></li></ul><p><strong>Examples</strong>:</p><ul><li><a href="https://github.com/alan-turing-institute/MLJModels.jl/blob/3687491b132be8493b6f7a322aedf66008caaab1/src/NearestNeighbors.jl#L62-L69">KNNClassifier</a> which uses <code>@mlj_model</code>,</li><li><a href="https://github.com/alan-turing-institute/MLJModels.jl/blob/3687491b132be8493b6f7a322aedf66008caaab1/src/XGBoost.jl#L17-L161">XGBoostRegressor</a> which does not.</li></ul><h3 id="Fit-1"><a class="docs-heading-anchor" href="#Fit-1">Fit</a><a class="docs-heading-anchor-permalink" href="#Fit-1" title="Permalink"></a></h3><p>The implementation of <code>fit</code> will look like</p><pre><code class="language-julia">function MLJModelInterface.fit(m::YourModel, verbosity, X, y, w=nothing)
    # body ...
    return (fitresult, cache, report)
end</code></pre><p>where <code>y</code> should only be there for a supervised model and <code>w</code> for a supervised model that supports sample weights.  You <strong>must</strong> type <code>verbosity</code> to <code>Int</code> and you <strong>must not</strong> type <code>X</code>, <code>y</code> and <code>w</code> (MLJ handles that).</p><h4 id="Regressor-1"><a class="docs-heading-anchor" href="#Regressor-1">Regressor</a><a class="docs-heading-anchor-permalink" href="#Regressor-1" title="Permalink"></a></h4><p>In the body of the <code>fit</code> function, you should assume that <code>X</code> is a table and that <code>y</code> is an <code>AbstractVector</code> (for multitask regression it may be a table).</p><p>Typical steps in the body of the <code>fit</code> function will be:</p><ul><li><p>forming a matrix-view of the data, possibly transposed if your model expects a <code>p x n</code> formalism (MLJ assumes columns are features by default i.e. <code>n x p</code>), use <code>MLJModelInterface.matrix</code> for this,</p></li><li><p>passing the data to your model,</p></li><li><p>returning the results as a tuple <code>(fitresult, cache, report)</code>.</p></li></ul><p>The <code>fitresult</code> part should contain everything that is needed at the <code>predict</code> or <code>transform</code> step, it should not be expected to be accessed by users.  The <code>cache</code> should be left to <code>nothing</code> for now. The <code>report</code> should be a <code>NamedTuple</code> with any auxiliary useful information that a user would want to know about the fit (e.g., feature rankings). See more on this below.</p><p><strong>Example</strong>: GLM&#39;s <a href="https://github.com/alan-turing-institute/MLJModels.jl/blob/3687491b132be8493b6f7a322aedf66008caaab1/src/GLM.jl#L95-L105">LinearRegressor</a></p><h4 id="Classifier-1"><a class="docs-heading-anchor" href="#Classifier-1">Classifier</a><a class="docs-heading-anchor-permalink" href="#Classifier-1" title="Permalink"></a></h4><p>For a classifier, the steps are fairly similar to a regressor with these differences:</p><ol><li><code>y</code> will be a categorical vector and you will typically want to use the integer encoding of <code>y</code> instead of <code>CategoricalValue</code>s; use <code>MLJModelInterface.int</code> for this.</li><li>You will need to pass the full pool of target labels (not just those observed in the training data) and additionally, in the <code>Deterministic</code> case, the encoding, to make these available to <code>predict</code>. A simple way to do this is to pass <code>y[1]</code> in the <code>fitresult</code>, for then <code>MLJModelInterface.classes(y[1])</code> is a complete list of possible categorical elements, and <code>d = MLJModelInterface.decoder(y[1])</code> is a method for recovering categorical elements from their integer representations (e.g., <code>d(2)</code> is the categorical element with <code>2</code> as encoding).</li><li>In the case of a <em>probabilistic</em> classifier you should pass all probabilities simultaneously to the <code>UnivariateFinite</code> constructor to get an abstract <code>UnivariateFinite</code> vector (type <code>UnivariateFiniteArray</code>) rather than use comprehension or broadcasting to get a vanilla vector. This is for performance reasons.</li></ol><p>If implementing a classifier, you should probably consult the more detailed instructions at <a href="../adding_models_for_general_use/#The-predict-method-1">The predict method</a>.</p><p><strong>Examples</strong>:</p><ul><li><p>GLM&#39;s <a href="https://github.com/alan-turing-institute/MLJModels.jl/blob/3687491b132be8493b6f7a322aedf66008caaab1/src/GLM.jl#L119-L131">BinaryClassifier</a> (<code>Probabilistic</code>)</p></li><li><p>LIBSVM&#39;s <a href="https://github.com/alan-turing-institute/MLJModels.jl/blob/master/src/LIBSVM.jl">SVC</a> (<code>Deterministic</code>)</p></li></ul><h4 id="Transformer-1"><a class="docs-heading-anchor" href="#Transformer-1">Transformer</a><a class="docs-heading-anchor-permalink" href="#Transformer-1" title="Permalink"></a></h4><p>Nothing special for a transformer.</p><p><strong>Example</strong>: <a href="https://github.com/alan-turing-institute/MLJModels.jl/blob/3687491b132be8493b6f7a322aedf66008caaab1/src/builtins/Transformers.jl#L54-L64">FillImputer</a></p><h3 id="Fitted-parameters-1"><a class="docs-heading-anchor" href="#Fitted-parameters-1">Fitted parameters</a><a class="docs-heading-anchor-permalink" href="#Fitted-parameters-1" title="Permalink"></a></h3><p>There is a function you can optionally implement which will return the learned parameters of your model for purposes of user-inspection. For instance, in the case of a linear regression, the user may want to get direct access to the coefficients and intercept. This should be as human and machine readable as practical (not a graphical representation) and the information should be combined in the form of a named tuple.</p><p>The function will always look like:</p><pre><code class="language-julia">function MLJModelInterface.fitted_params(model::YourModel, fitresult)
    # extract what&#39;s relevant from `fitresult`
    # ...
    # then return as a NamedTuple
    return (learned_param1 = ..., learned_param2 = ...)
end</code></pre><p><strong>Example</strong>: for <a href="https://github.com/alan-turing-institute/MLJModels.jl/blob/3687491b132be8493b6f7a322aedf66008caaab1/src/GLM.jl#L133-L137">GLM models</a></p><h3 id="Summary-of-user-interface-points-(or,-What-to-put-where?)-1"><a class="docs-heading-anchor" href="#Summary-of-user-interface-points-(or,-What-to-put-where?)-1">Summary of user interface points (or, What to put where?)</a><a class="docs-heading-anchor-permalink" href="#Summary-of-user-interface-points-(or,-What-to-put-where?)-1" title="Permalink"></a></h3><p>Recall that the <code>fitresult</code> returned as part of <code>fit</code> represents everything needed by <code>predict</code> (or <code>transform</code>) to make new predictions. It is not intended to be directly inspected by the user. Here is a summary of the interface points for users that your implementation creates:</p><ul><li>Use <code>fitted_params</code> to expose <em>learned parameters</em>, such as linear coefficients, to the user in a machine and human readable form (for re-use in another model, for example).</li><li>Use the fields of your model struct for <em>hyperparameters</em>, i.e., those parameters declared by the user ahead of time that generally affect the outcome of training. It is okay to add &quot;control&quot; parameters (such a specifying an <code>acceleration</code> parameter specifying computational resources, as <a href="https://github.com/alan-turing-institute/MLJ.jl/blob/master/src/ensembles.jl#L193">here</a>).</li><li>Use <code>report</code> to return <em>everything else</em>, including model-specific <em>methods</em> (or other callable objects). This includes: feature rankings, decision boundaries, SVM support vectors, clustering centres, methods for visualizing training outcomes, methods for saving learned parameters in a custom format, degrees of freedom, deviance, etc. If there is a performance cost to extra functionality you want to expose, the functionality can be toggled on/off through a hyperparameter, but this should otherwise be avoided. For, example, in a decision tree model <code>report.print_tree(depth)</code> might generate a pretty tree representation of the learned tree, up to the specified <code>depth</code>.</li></ul><h3 id="Predict/Transform-1"><a class="docs-heading-anchor" href="#Predict/Transform-1">Predict/Transform</a><a class="docs-heading-anchor-permalink" href="#Predict/Transform-1" title="Permalink"></a></h3><p>The implementation of <code>predict</code> (for a supervised model) or <code>transform</code> (for an unsupervised one) will look like:</p><pre><code class="language-julia">function MLJModelInterface.predict(m::YourModel, fitresult, Xnew)
    # ...
end</code></pre><p>Here <code>Xnew</code> is expected to be a table and part of the logic in <code>predict</code> or <code>transform</code> may be similar to that in <code>fit</code>.</p><p>The values returned should be:</p><table><tr><th style="text-align: right">model subtype</th><th style="text-align: right">return value of predict/transform</th></tr><tr><td style="text-align: right"><code>Deterministic</code></td><td style="text-align: right">vector of values (or table if multi-target)</td></tr><tr><td style="text-align: right"><code>Probabilistic</code></td><td style="text-align: right">vector of <code>Distribution</code> objects, for classifiers in particular, a vector of <code>UnivariateFinite</code></td></tr><tr><td style="text-align: right"><code>Unsupervised</code></td><td style="text-align: right">table</td></tr></table><p>In the case of a <code>Probabilistic</code> model, you may further want to implement a <code>predict_mean</code> or a <code>predict_mode</code>. However, MLJModelInterface provides fallbacks, defined in terms of <code>predict</code>, whose performance may suffice.</p><p><strong>Examples</strong></p><ul><li>Deterministic regression: <a href="https://github.com/alan-turing-institute/MLJModels.jl/blob/3687491b132be8493b6f7a322aedf66008caaab1/src/NearestNeighbors.jl#L124-L145">KNNRegressor</a></li><li>Probabilistic regression: <a href="https://github.com/alan-turing-institute/MLJModels.jl/blob/3687491b132be8493b6f7a322aedf66008caaab1/src/GLM.jl#L154-L158">LinearRegressor</a> and the <a href="https://github.com/alan-turing-institute/MLJModels.jl/blob/3687491b132be8493b6f7a322aedf66008caaab1/src/GLM.jl#L144-L147"><code>predict_mean</code></a></li><li>Probabilistic classification: <a href="https://github.com/alan-turing-institute/MLJModels.jl/blob/3687491b132be8493b6f7a322aedf66008caaab1/src/GLM.jl#L165-L168">LogisticClassifier</a></li></ul><h3 id="Metadata-1"><a class="docs-heading-anchor" href="#Metadata-1">Metadata</a><a class="docs-heading-anchor-permalink" href="#Metadata-1" title="Permalink"></a></h3><p>Adding metadata for your model(s) is crucial for the discoverability of your package and its models and to make sure your model is used with data it can handle.  You can individually overload a number of trait functions that encode this metadata by following the instuctions in <a href="../adding_models_for_general_use/#Adding-Models-for-General-Use-1">Adding Models for General Use</a>), which also explains these traits in more detail. However, your most convenient option is to use <code>metadata_model</code> and <code>metadata_pkg</code> functionalities from <code>MLJModelInterface</code> to do this:</p><pre><code class="language-julia">const ALL_MODELS = Union{YourModel1, YourModel2, ...}

MLJModelInterface.metadata_pkg.(ALL_MODELS
    name = &quot;YourPackage&quot;,
    uuid = &quot;6ee0df7b-...&quot;, # see your Project.toml
    url  = &quot;https://...&quot;,  # URL to your package repo
    julia = true,          # is it written entirely in Julia?
    license = &quot;MIT&quot;,       # your package license
    is_wrapper = false,    # does it wrap around some other package?
)

# Then for each model,
MLJModelInterface.metadata_model(YourModel1,
    input_scitype   = MLJModelInterface.Table(MLJModelInterface.Continuous),  # what input data is supported?
    target_scitype  = AbstractVector{MLJModelInterface.Continuous},           # for a supervised model, what target?
    output_scitype  = MLJModelInterface.Table(MLJModelInterface.Continuous),  # for an unsupervised, what output?
    supports_weights = false,                                                  # does the model support sample weights?
    descr   = &quot;A short description of your model&quot;
	load_path    = &quot;YourPackage.SubModuleContainingModelStructDefinition.YourModel1&quot;
    )</code></pre><p><em>Important.</em> Do not omit the <code>load_path</code> specification. Without a correct <code>load_path</code> MLJ will be unable to import your model.</p><p><strong>Examples</strong>:</p><ul><li>package metadata<ul><li><a href="https://github.com/alan-turing-institute/MLJModels.jl/blob/3687491b132be8493b6f7a322aedf66008caaab1/src/GLM.jl#L179-L186">GLM</a></li><li><a href="https://github.com/alan-turing-institute/MLJLinearModels.jl/blob/289a373a8357c4afc191711d0218aa1523e97f70/src/mlj/interface.jl#L91-L97">MLJLinearModels</a></li></ul></li><li>model metadata<ul><li><a href="https://github.com/alan-turing-institute/MLJModels.jl/blob/3687491b132be8493b6f7a322aedf66008caaab1/src/GLM.jl#L188-L193">LinearRegressor</a></li><li><a href="https://github.com/alan-turing-institute/MLJModels.jl/blob/3687491b132be8493b6f7a322aedf66008caaab1/src/DecisionTree.jl#L225-L229">DecisionTree</a></li><li><a href="https://github.com/alan-turing-institute/MLJLinearModels.jl/blob/289a373a8357c4afc191711d0218aa1523e97f70/src/mlj/interface.jl#L105-L111">A series of regressors</a></li></ul></li></ul><h3 id="Adding-a-model-to-the-model-registry-1"><a class="docs-heading-anchor" href="#Adding-a-model-to-the-model-registry-1">Adding a model to the model registry</a><a class="docs-heading-anchor-permalink" href="#Adding-a-model-to-the-model-registry-1" title="Permalink"></a></h3><p>See <a href="https://github.com/alan-turing-institute/MLJModels.jl/tree/master#instructions-for-updating-the-mlj-model-registry">here</a>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../simple_user_defined_models/">« Simple User Defined Models</a><a class="docs-footer-nextpage" href="../adding_models_for_general_use/">Adding Models for General Use »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 30 March 2021 04:01">Tuesday 30 March 2021</span>. Using Julia version 1.6.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
