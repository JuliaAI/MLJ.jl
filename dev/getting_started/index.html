<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Launch Pad · MLJ</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>MLJ</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Launch Pad</a><ul class="internal"></ul></li><li><a class="toctext" href="../scientific_data_types/">Scientific<em>Data</em>types</a></li><li><a class="toctext" href="../adding_new_models/">Adding new Models</a></li><li><a class="toctext" href="../internals/">Internals</a></li><li><a class="toctext" href="../glossary/">Glossary</a></li><li><a class="toctext" href="../NEWS/">News</a></li><li><a class="toctext" href="../">MLJ.jl</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Launch Pad</a></li></ul><a class="edit-page" href="https://github.com/alan-turing-institute/MLJ.jl/blob/master/docs/src/getting_started.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Launch Pad</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Getting-Started-1" href="#Getting-Started-1">Getting Started</a></h1><h3><a class="nav-anchor" id="Basic-supervised-training-and-testing-1" href="#Basic-supervised-training-and-testing-1">Basic supervised training and testing</a></h3><pre><code class="language-julia">julia&gt; using MLJ
julia&gt; using RDatasets
julia&gt; iris = dataset(&quot;datasets&quot;, &quot;iris&quot;); # a DataFrame</code></pre><p>In MLJ one can either wrap data for supervised learning in a formal <em>task</em> (see <a href="tasks.jl">Working with Tasks</a>), or work directly with the data, split into its input and target parts:</p><pre><code class="language-julia">julia&gt; const X = iris[:, 1:4];
julia&gt; const y = iris[:, 5];</code></pre><p>A <em>model</em> is a container for hyperparameters:</p><pre><code class="language-julia">julia&gt; @load DecisionTreeClassifier
julia&gt; tree_model = DecisionTreeClassifier(target_type=String, max_depth=2)

import MLJModels ✔
import DecisionTree ✔
import MLJModels.DecisionTree_.DecisionTreeClassifier ✔

# DecisionTreeClassifier{String} @ 2…98: 
target_type             =&gt;   String
pruning_purity          =&gt;   1.0
max_depth               =&gt;   2
min_samples_leaf        =&gt;   1
min_samples_split       =&gt;   2
min_purity_increase     =&gt;   0.0
n_subfeatures           =&gt;   0.0
display_depth           =&gt;   5
post_prune              =&gt;   false
merge_purity_threshold  =&gt;   0.9</code></pre><p>Wrapping the model in data creates a <em>machine</em> which will store training outcomes (called <em>fit-results</em>):</p><pre><code class="language-julia">julia&gt; tree = machine(tree_model, X, y)

# Machine{DecisionTreeClassifier{S…} @ 1…36: 
model                   =&gt;   DecisionTreeClassifier{String} @ 2…98
fitresult               =&gt;   (undefined)
cache                   =&gt;   (undefined)
args                    =&gt;   (omitted Tuple{DataFrame,CategoricalArray{String,1,UInt8,String,CategoricalString{UInt8},Union{}}} of length 2)
report                  =&gt;   empty Dict{Symbol,Any}
rows                    =&gt;   (undefined)</code></pre><p>Training and testing on a hold-out set:</p><pre><code class="language-julia">julia&gt; train, test = partition(eachindex(y), 0.7, shuffle=true); # 70:30 split
julia&gt; fit!(tree, rows=train)
julia&gt; yhat = predict(tree, X[test,:]);
julia&gt; misclassification_rate(yhat, y[test]);

┌ Info: Training Machine{DecisionTreeClassifier{S…} @ 1…36.
└ @ MLJ /Users/anthony/Dropbox/Julia7/MLJ/src/machines.jl:68
0.08888888888888889</code></pre><p>Or, in one line:</p><pre><code class="language-julia">julia&gt; evaluate!(tree, resampling=Holdout(fraction_train=0.7, shuffle=true), measure=misclassification_rate)

0.08888888888888889</code></pre><p>Changing a hyperparameter and re-evaluating:</p><pre><code class="language-julia">julia&gt; tree_model.max_depth = 3
julia&gt; evaluate!(tree, resampling=Holdout(fraction_train=0.5, shuffle=true), measure=misclassification_rate)

0.06666666666666667</code></pre><h3><a class="nav-anchor" id="Next-steps-1" href="#Next-steps-1">Next steps</a></h3><p>To learn a little more about what MLJ can do, take the MLJ <a href="../tour.ipynb">tour</a>. Read the remainder of this document before considering more serious use of MLJ.</p><h3><a class="nav-anchor" id="Prerequisites-1" href="#Prerequisites-1">Prerequisites</a></h3><p>MLJ assumes some familiarity with the <a href="https://github.com/JuliaData/CategoricalArrays.jl">CategoricalArrays.jl</a> package, used for representing categorical data. For probabilistic predictors, a basic acquaintance with <a href="https://github.com/JuliaStats/Distributions.jl">Distributions.jl</a> is also assumed.</p><h3><a class="nav-anchor" id="Data-1" href="#Data-1">Data</a></h3><p>While MLJ is data <em>container</em> agnostic it is very fussy about <em>element</em> types. The MLJ user should acquaint themselves with some basic assumptions about the form of data expected by MLJ, as outlined below. </p><blockquote><p>Eventually task constructors will make the coercion of data into the requisite form more automated. The following remarks will be less critical to the casual user. At present, however, task constructors assume data is in the requisite form.</p></blockquote><p>In principle, anywhere a table is expected in MLJ (eg, <code>X</code> above) any tabular format supporting the <a href="Tables.jl">Tables.jl</a> interface is allowed. (At present our API is more restrictive; see this <a href="https://github.com/JuliaData/Tables.jl/issues/74">issue</a> with Tables.jl. If your Tables.jl compatible format is not working in MLJ, please post an issue.) In particular, <code>DataFrame</code>, <code>JuliaDB.IndexedTable</code> and <code>TypedTables.Table</code> objects are supported, as are named tuples of equi-length vectors (&quot;column tables&quot; in Tables.jl parlance).</p><p>A single feature (such as the target <code>y</code> above) is expected to be a <code>Vector</code> or <code>CategoricalVector</code>, according to the <em>scientific type</em> of the data (see below). A multivariate target can be any table.</p><p>On the other hand, the <em>element types</em> you use to represent your data has implicit consequences about how MLJ will interpret that data.</p><p>To articulate MLJ&#39;s conventions about data representation, MLJ distinguishes between <em>machine</em> data types on the one hand (<code>Float64</code>, <code>Bool</code>, <code>String</code>, etc) and <em>scientific data types</em> on the other, represented by new Julia types: <code>Continuous</code>, <code>Multiclass{N}</code>, <code>FiniteOrderedFactor{N}</code>, and <code>Count</code> (unbounded ordered factor), with obvious interpretations. These types, which are part of a type hierarchy (see <a href="../scientific_data_types/">Scientific Data Types</a>), are used by MLJ for dispatch, but have no corresponding instances.</p><p>Scientific types appear when querying model metadata, as in this example:</p><pre><code class="language-julia">julia&gt; info(&quot;DecisionTreeClassifier&quot;)[:target_scitype]

Union{Multiclass,FiniteOrderedFactor}</code></pre><p><strong>Basic data convention</strong> The scientific type of data that a Julia object <code>x</code> can represent is defined by <code>scitype(x)</code>. If <code>scitype(x) == Other</code>, then <code>x</code> cannot represent scalar data in MLJ.</p><pre><code class="language-julia">julia&gt; (scitype(42), scitype(π), scitype(&quot;Julia&quot;))

(Count, Continuous, MLJBase.Other)</code></pre><p>In particular, <em>integers cannot be used to represent</em> <code>Multiclass</code> <em>or</em> <code>FiniteOrderedFactor</code> <em>data</em>; these can be represented by an unordered or ordered <code>CategoricalValue</code> or <code>CategoricalString</code>:</p><table><tr><th><code>T</code></th><th><code>scitype(x)</code> for <code>x::T</code></th></tr><tr><td><code>Missing</code></td><td><code>Missing</code></td></tr><tr><td><code>Real</code></td><td><code>Continuous</code></td></tr><tr><td><code>Integer</code></td><td><code>Count</code></td></tr><tr><td><code>CategoricalValue</code></td><td><code>Multiclass{N}</code> where <code>N = nlevels(x)</code>, provided <code>x.pool.ordered == false</code></td></tr><tr><td><code>CategoricalString</code></td><td><code>Multiclass{N}</code> where <code>N = nlevels(x)</code>, provided <code>x.pool.ordered == false</code></td></tr><tr><td><code>CategoricalValue</code></td><td><code>FiniteOrderedFactor{N}</code> where <code>N = nlevels(x)</code>, provided <code>x.pool.ordered == true</code></td></tr><tr><td><code>CategoricalString</code></td><td><code>FiniteOrderedFactor{N}</code> where <code>N = nlevels(x)</code> provided <code>x.pool.ordered == true</code></td></tr><tr><td><code>Integer</code></td><td><code>Count</code></td></tr></table><p>Here <code>nlevels(x) = length(levels(x.pool))</code>.</p><footer><hr/><a class="next" href="../scientific_data_types/"><span class="direction">Next</span><span class="title">Scientific<em>Data</em>types</span></a></footer></article></body></html>
